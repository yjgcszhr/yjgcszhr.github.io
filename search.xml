<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>杂谈1</title>
      <link href="posts/e70.html"/>
      <url>posts/e70.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>systemverilog学习日记（一）</title>
      <link href="posts/a99d.html"/>
      <url>posts/a99d.html</url>
      
        <content type="html"><![CDATA[<p>IC前端设计需要设计人员编写testbench来进行对模块的初步前仿，一般是用verilog来写，但是verilog语言结构简单，编写一个稍微复杂的仿真环境很是费力，所以systemverilog便被开发设计出来。systemVerilog是一门高级语言，官方描述为：<br>SystemVerilog简称为SV语言，是一种相当新的语言，它建立在Verilog语言的基础上，是 IEEE 1364 Verilog-2001 标准的扩展增强，兼容Verilog 2001，将硬件描述语言（HDL）与现代的高层级验证语言（HVL）结合了起来，并新近成为下一代硬件设计和验证的语言。<br>既可以用作设计又可以用作验证，功能十分强大，所以多学一门systemverilog会让你如虎添翼。笔者本着学无止境的态度，开始接触学习systemverilog.开始吧，一步一个脚印。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="内建数据类型"><a href="#内建数据类型" class="headerlink" title="内建数据类型"></a>内建数据类型</h3><p>什么语言一开始都要从基本数据类型学起，sv也不例外。sv的数据类型像是继承了c语言的很多特色，除了byte 、int、shortint、longint这些c语言里经常看到的，SV还加了logic<br>、bit等。接下我解释一下这些类型怎么个用法。</p><blockquote><p>logic: 只能双状态，0或者1，reg型和wire型综合，只能被单一驱动<br>bit: 四状态，0,1，高阻z，未知x，这个比较常用，可以自由定义位宽，例如</p></blockquote><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">bit b;    &#x2F;&#x2F;单比特bit [15:0] data;&#x2F;&#x2F;16比特数据，无符号rand bit [15:0] r_data;&#x2F;&#x2F; 写testbench时经常会加上rand,用于生成随机化数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>byte: 8比特有符号数据<br>int: 32比特有符号数据<br>shortint: 16比特有符号整数<br>longint: 64比特有符号整数</p></blockquote><p><strong>这些都可以用bit来代替，而且Bit是无符号的，bit [7:0] 等于 byte unsigned</strong></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组可分成定宽数组和动态数组，定宽数组又可以分成压缩数组和非压缩数组，</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">bit [7:0] data [0:3] &#x2F;&#x2F;生成位宽8，深度为4的数组,这是非压缩数组&#x2F;&#x2F;也可以这样表达bit [0:3] [7:0]  data;&#x2F;&#x2F;压缩数组，作用类似上面表达bit [0:3] [7:0] barray[3]&#x2F;&#x2F;这个用法我也没见过，书上是这么定义的，其存放示意图如下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>压缩数组的结构是这样的<br><img src="/img/sv1/f1.png" alt="图1"><br><img src="/img/sv1/f2.png" alt="图2"></p><p>动态数据是位宽暂时无法确定的数组，其在声明时使用空的[],在使用时需要调用new[]，同时方括号里要填上数组的宽度，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">int data[];&#x2F;&#x2F;声明动态数组initial begindata&#x3D;new[4];&#x2F;&#x2F;数组宽度为4end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h3><p>sv提供typedef 和 struct来为用户自定义数据类型</p><blockquote><p>struct和typedef用法和c语言的差不多，直接代码解释：</p></blockquote><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">typedef struct &#123;int a,b,c;&#125; usr_data;&#x2F;&#x2F;创建usr_data结构，包括三个int数据typedf int unsigned uint;&#x2F;&#x2F;uint 和 int unsigned等效，下面语句可以直接使用uint<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>端口与端口之间的连接一般通过input和output来传输信号线，当这些信号线数目大的时候，信号线连接就会出现很多的问题和麻烦，于是接口interface就被提出，interface的作用就是把一群信号线捆绑成一个接口，里面可以有时钟有复位信号，也有多位宽数据。接口可以被方便引用，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">interface arb_if (input bit clk); logic [1:0] grant,request; logic rst; endinterface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>发没发现接口里的数据类型都是logic,而不是wire,想想什么原因？<br>以上是我们定义了一个接口，接下来展示我们怎么使用它。如果需要用到接口里的某个信号，我们只要写<code>接口名.信号名</code>，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">module test (arb_if arbif);&#x2F;&#x2F;接口名 自定义名always @ (posedge arbif. clk or posedge arbif. rst) begin if (arbif. rst) arbif.grant&lt;&#x3D;2&#39;bOO; else ••• endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>PS:接口里的信号必须使用非阻塞赋值</strong></em></p><h3 id="modport"><a href="#modport" class="headerlink" title="modport"></a>modport</h3><p>modport的功能是把interface里的信号分组，选取一些信号作为输入，一些信号作为输出，modport 名（input/output 信号名,…..）例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">interface arb_if (input bit clk); logic [ 1: O] grant, reques 七；logic rst; modport TEST (output request, rst, input grant, clk); modport DUT (input request,rst,clk, output grant);modport MONITOR (input request,grant,rst,clk); endinterface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那我们怎么去用它呢？很简单，就是 <strong>接口名.modport名 自定义接口名</strong> ，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">module arb (arb_if.DUT arbif); ••• endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="clocking"><a href="#clocking" class="headerlink" title="clocking"></a>clocking</h3><p>每个接口可以有多个时钟块，<code>clocking cb @（posedge clk）</code>的作用是表明我这个区域里的信号只在我这时钟上升沿有效，具体怎么表达例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">clocking cb @ (posedge clk) ；／／声明 cboutput request; input grant；endclocking<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既然学了clocking，那么modport的写法我们又能这么写了：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">modport TEST (clocking cb, ／／使用 cboutput rst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>怎么用这个接口呢？那就是像套娃一样，怎么套进去的怎么拿出来，</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">program automatic test (arb_if.TEST arbif); &#x2F;&#x2F;program习惯加上automatic,initial begin arbif. cb. request&lt;&#x3D; 2&#39;bOl;   &#x2F;&#x2F;接口里的clocking模块里的信号$display( ＂@%t: Drove req&#x3D; 01&quot;, $time); repeat (2) @arbif.cb;   &#x2F;&#x2F;重复两个clocking模块里的时钟if (arbif.cb.grant! &#x3D;2&#39;b01) $display (&quot;@%t: al: grant! &#x3D; 2&#39;bOl&quot;, $time); end endprogram : test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sytemverilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线（2）——axi4_stream总线</title>
      <link href="posts/4372.html"/>
      <url>posts/4372.html</url>
      
        <content type="html"><![CDATA[<p>AXI4-stream接口连接产生数据的一个主设备和接收数据的一个从设备，用来传播数据流，和其他AXI协议不同的是，AXI4-stream不需要主机提供地址，使用相对方便，当传输单数据时其数据传输时序与第一讲的APB总线就少了个地址信息的，其他大致相同。</p><h2 id="接口信号"><a href="#接口信号" class="headerlink" title="接口信号"></a>接口信号</h2><blockquote><p>ACLK: 系统时钟<br>ARESTEN: 复位信号，低电平有效<br>TVALID: 表示主机正在进行数据传输<br>TREADY: 表示从机已经做好数据接收的准备<br>TDATA: 传输的数据<br>TSTRB: 字节控制信号，按照byte指定data中的哪个byte是地址信息或者数据信息；<br>TKEEP: 字节控制信号，指定data中的哪个byte是字节修饰符，哪个是有效的。<br>TLAST: 表示数据流的最后标志<br>TID: 标识符，表示不同数据流<br>TDEST: 提供路由信息<br>TUSER: 用户自定义信息<br><strong>PS:如果TKEEP引脚不在的话，TSTRB承担指定字节有效的功能</strong></p></blockquote><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><blockquote><p>首先主设备给出数据和控制信息，并拉高TVALID信号，然后等待从机的TREADY信号，一旦TREADY信号为高，数据就开始传输，一般来说，无论TVALID和TREADY谁先到达，只有当TVALID和TREADY信号同时为高时，一次传输才算完成。如果连续多包数据传输的话，TVALID将一直拉高，直到最后一包数据传输，TLAST拉高。传输完成后，TVALID拉低，TLAST拉低。<br>直接放图会更容易理解。以下为TVALID和TREADY握手示意图：<br><img src="/img/axi_stream/d1.png" alt="TVALID在TREADY前握手"><br><img src="/img/axi_stream/d2.png" alt="TVALID在TREADY后握手"><br><img src="/img/axi_stream/d3.png" alt="TVALID和TREADY同时握手"></p></blockquote><p>多次连续传输示意图，<br><img src="/img/axi_stream/d4.png" alt="axi_stream多数据传输"></p><h2 id="修改自定义AXI4-stream-ip核"><a href="#修改自定义AXI4-stream-ip核" class="headerlink" title="修改自定义AXI4-stream ip核"></a>修改自定义AXI4-stream ip核</h2><blockquote><p>官方生成的带有AXI4-stream接口的IP核，是用一个二维数组来存放stream——data，但这不方便读出来进行二次开发，于是我做了一点改动，官方源码部分截图如下<br><img src="/img/axi_stream/d5.png"><br>笔者修改后的源码部分：</p></blockquote><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">   reg  [0 : NUMBER_OF_INPUT_WORDS-1] [C_S_AXIS_TDATA_WIDTH-1:0] data_fifo ;&#x2F;&#x2F; FIFO Implementationgenerate   for(byte_index&#x3D;0; byte_index&lt;&#x3D; (C_S_AXIS_TDATA_WIDTH&#x2F;8-1); byte_index&#x3D;byte_index+1)  begin:FIFO_GEN   &#x2F;&#x2F; reg  [(C_S_AXIS_TDATA_WIDTH&#x2F;4)-1:0] stream_data_fifo [0 : NUMBER_OF_INPUT_WORDS-1];    &#x2F;&#x2F; Streaming input data is stored in FIFO    always @( posedge S_AXIS_ACLK )    begin      if (fifo_wren &amp;&amp; S_AXIS_TSTRB[byte_index])        begin          data_fifo[write_pointer][(byte_index*8+7) -: 8] &lt;&#x3D; S_AXIS_TDATA[(byte_index*8+7) -: 8];         end      end&#x2F;&#x2F; always@(*) begin &#x2F;&#x2F; data_fifo[write_pointer][(byte_index*8+7) -: 8] &#x3D; stream_data_fifo[write_pointer];&#x2F;&#x2F; end   end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>PS:图片来自网络</strong></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AXI4-stream </tag>
            
            <tag> AMBA总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线（1）——APB总线</title>
      <link href="posts/982f.html"/>
      <url>posts/982f.html</url>
      
        <content type="html"><![CDATA[<p>AMBA协议是一个开放标准的片上互联规范，用于SOC功能模块的连接和管理。目前，已经推出来四代版本的AMBA规范。版本2的AMBA规范定义了3个总线接口：<br>AHB（advanced high-performance bus）：高级高性能总线<br>ASB（advanced sysytem bus ）: 高级系统总线<br>APB（advanced peripheral bus）：高级外设总线</p><p>APB总线用在低带宽和不需要高性能总线的外部设备上，采用流水线结构，所有信号仅与时钟上升沿有关。每次传输至少消耗2个周期。</p><h2 id="APB-信号："><a href="#APB-信号：" class="headerlink" title="APB 信号："></a>APB 信号：</h2><blockquote><p>PCLK：时钟源<br>PRESETN：系统复位信号，低电平有效<br>PADDR：地址总线，最大32位<br>PPROT：保护类型，普通传输，安全传输，数据访问或指令访问<br>PSELx: 片选信号，每个从设备配有一个<br>PENABLE: 使能信号，表示数据传输的第二个及之后的周期。<br>PWRITE: 读写控制信号，高电平为写访问，低电平为读访问<br>PWDATA: 写数据，<br>PSTRB: 字节有效信号，每一个字节对应一位，如果数据位为32，则PSTRB为4位<br>PREADY: 从设备准备好信号，<br>PRDATA: 读取的数据。在读周期里，从设备驱动该总线，最大32位<br>PSLVERR: 传输失败信号</p></blockquote><h2 id="APB-写传输"><a href="#APB-写传输" class="headerlink" title="APB 写传输"></a>APB 写传输</h2><blockquote><p>APB 写传输包括两种类型：无等待状态写传输和有等待状态写传输<br>（1）T1周期<br>给出PADDR，PWRITE，PSELx，PWDATA信号，也称为建立周期<br>（2）T2周期及之后<br>抬高PENBLE信号，等待PREADY信号，如果刚好则是无等待状态传输，否则，PENABLE信号一直保持，直到PREADY信号出现，传输结束，这个是有等待状态传输。<br><img src="/img/apb/c1.png" alt="无等待状态写传输"><br><img src="/img/apb/c2.png" alt="有等待状态写传输"></p></blockquote><h2 id="APB读传输"><a href="#APB读传输" class="headerlink" title="APB读传输"></a>APB读传输</h2><blockquote><p>APB 读传输包括两种类型：无等待状态读传输和有等待状态读传输<br>（1）T1周期<br>给出PADDR，PWRITE，PSELx信号，<br>（2）T2周期及以后<br>抬高PENABLE信号，等待PREADY和PRDATA，如果刚好出现就是无等待读传输，否则PENABLE信号一直保持，直到<br>PREADY和PRDATA出现，这个是有等待状态读传输。<br><img src="/img/apb/c3.png" alt="无等待状态读传输"><br><img src="/img/apb/c4.png" alt="有等待状态读传输"></p></blockquote><h2 id="APB传输状态机"><a href="#APB传输状态机" class="headerlink" title="APB传输状态机"></a>APB传输状态机</h2><blockquote><p><strong>1.IDLE</strong><br>默认状态，无操作<br><strong>2.SETUP</strong><br>建立周期，为一个时钟周期，提供必要的信号.如PSELx信号，PADDR信号等。<br><strong>3.ACCESS</strong><br>数据传输，PENABLE拉高，等待PREADY信号。如果PREADY信号为低，则保持当前状态，否则根据是否要接下来继续在当前地址传输数据来确定下一个状态。具体可看下面的状态机图。</p></blockquote><p><img src="/img/apb/c5.png" alt="APB总线状态机"></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APB总线 </tag>
            
            <tag> AMBA总线&#39; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序约束入门</title>
      <link href="posts/fd6e.html"/>
      <url>posts/fd6e.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-建立时间"><a href="#1-建立时间" class="headerlink" title="1. 建立时间"></a>1. 建立时间</h3><blockquote><p>是指在触发器的时钟信号上升沿到来以前，数据稳定不变的时间，如果建立时间不够，数据将不能在这个时钟上升沿被打入触发器；</p></blockquote><h3 id="2-保持时间"><a href="#2-保持时间" class="headerlink" title="2. 保持时间"></a>2. 保持时间</h3><blockquote><p>是指在触发器的时钟信号上升沿到来以后，数据稳定不变的时间，如果保持时间不够，数据同样不能被打入触发器。</p></blockquote><h3 id="3-时间裕量"><a href="#3-时间裕量" class="headerlink" title="3. 时间裕量"></a>3. 时间裕量</h3><blockquote><p>建立时间裕量：Tsetup_slack<br>就是说在满足建立时间的情况下，所剩余的时间长度为多少，一般大于0；<br>保持时间裕量：Thold_slack<br>就是说在满足保持时间的情况下，所剩余的时间长度为多少，一般大于0；</p></blockquote><h3 id="4-组合逻辑电路延迟-Tlogic"><a href="#4-组合逻辑电路延迟-Tlogic" class="headerlink" title="4. 组合逻辑电路延迟 Tlogic"></a>4. 组合逻辑电路延迟 Tlogic</h3><p><img src="/img/STA/b1.png" alt="寄存器时序电路图"><br><img src="/img/STA/b2.png" alt="公式"></p><h2 id="时序分析"><a href="#时序分析" class="headerlink" title="时序分析"></a>时序分析</h2><h3 id="1-建立时间裕量"><a href="#1-建立时间裕量" class="headerlink" title="1. 建立时间裕量"></a>1. 建立时间裕量</h3><blockquote><p>如下图。展示的是D1触发器输出端Q的波形和D2触发器输入端D的波形<br><img src="/img/STA/b3.png" alt="波形图"></p></blockquote><blockquote><p>有图可见。D2触发器输入端数据D提前于clk上升沿的时间为 tcycle-(tcq+tlogic)。如果要满足建立时间的话，就要Tcycle-(Tcq+Tlogic) &gt; Tsetup,<br>即Tsetup_slack = Tcycle-(Tcq+Tlogic) - Tsetup &gt; 0 ,如果加上时钟偏移Tclockdelay,就是Tcycle-(Tcq+Tlogic) + Tclockdelay &gt; Tsetup,<br>即Tsetup_slack = Tcycle-(Tcq+Tlogic) - Tsetup + Tclockdelay &gt; 0，如下图<br><img src="/img/STA/b5.png" alt="波形图"></p></blockquote><h3 id="2-保持时间裕量"><a href="#2-保持时间裕量" class="headerlink" title="2. 保持时间裕量"></a>2. 保持时间裕量</h3><blockquote><p>如下图，展示的是D1触发器输出端Q的波形和D2触发器输入端D的波形<br><img src="/img/STA/b4.png" alt="波形图"></p></blockquote><blockquote><p>有图可见。D2触发器输入端数据D在clk上升沿到达后的可以持续时间为 Tcq+Tlogic。如果要满足建立时间的话，就要Tcq+Tlogic &gt; Thold,<br>即Thold_slack = Tcq+Tlogic - Thold &gt; 0 ,如果加上时钟偏移Tclockdelay,就是Tcq+Tlogic-Tclockdelay &gt; Thold,<br>即Tcq+Tlogic-Tclockdelay-Thold &gt; 0，如下图<br><img src="/img/STA/b6.png" alt="波形图"></p></blockquote><p><em><strong>PS:图片来自网络</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC设计 </tag>
            
            <tag> STA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vcs+verdi安装经历</title>
      <link href="posts/d3e2.html"/>
      <url>posts/d3e2.html</url>
      
        <content type="html"><![CDATA[<p>一直以来我都使用modelsim来进行仿真，也偶尔使用debussy查看波形，最近在别人的推荐下，我开始尝试使用vcs+verdi环境，<br>这篇文章用来记录自己苦逼的安装经历。之前自己下载了vcs verdi sysnopsys等安装包，动手安装但始终会出现一些问题，鉴于<br>时间宝贵，我就直接找了现成安装好的资源。<br>此处感谢微信公众号“芯王国”提供的已经安装好sysnopsys全家桶的vmware虚拟机资源。</p><h2 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h2><blockquote><p>百度云盘链接：<a href="https://pan.baidu.com/s/1enBg_oE8qw9EhU1G9M1qdQ">https://pan.baidu.com/s/1enBg_oE8qw9EhU1G9M1qdQ</a><br>  提取码：8bhi<br>  下载所有文件，然后解压后缀名为.zip的文件，使用vmware打开启动，选择“我已移动”</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>使用terminal终端输入verdi,会出现error:找不到liscense<br>此处我发现公众号提供的虚拟机没有写好环境变量文件，所以我们需要自己去配置。打开etc目录，找到bashrc文件进行修改，或者<br>terminal终端输入</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cd &#x2F;etcsudo gedit bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在bashrc最后添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">export DVE_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;vcs&#x2F;O-2018.09-SP2export VCS_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;vcs&#x2F;O-2018.09-SP2export VCS_MX_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;vcs-mx&#x2F;O-2018.09-SP2export LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;synopsys&#x2F;verdi&#x2F;Verdi_O-2018.09-SP2&#x2F;share&#x2F;PLI&#x2F;VCS&#x2F;LINUX64export VERDI_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;verdi&#x2F;Verdi_O-2018.09-SP2export SCL_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;scl&#x2F;2018.06#dvePATH&#x3D;$PATH:$VCS_HOME&#x2F;gui&#x2F;dve&#x2F;binalias dve&#x3D;&quot;dve&quot;#VCSPATH&#x3D;$PATH:$VCS_HOME&#x2F;binalias vcs&#x3D;&quot;vcs&quot;#VERDIPATH&#x3D;$PATH:$VERDI_HOME&#x2F;binalias verdi&#x3D;&quot;verdi&quot;#sclPATH&#x3D;$PATH:$SCL_HOME&#x2F;linux64&#x2F;binexport VCS_ARCH_OVERRIDE&#x3D;linux#LICENCEexport LM_LICENSE_FILE&#x3D;27000@localhost.localdomainalias lmg_synopsys&#x3D;&quot;lmgrd -c &#x2F;home&#x2F;synopsys&#x2F;scl&#x2F;2018.06&#x2F;admin&#x2F;license&#x2F;Synopsys.dat&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>点击保存，然后terminal输入：<br><code>source bashrc</code><br><code>lmg_synopsys</code>,<br>我们可以验证license是否正确，可以输入verdi<br>如果没有出现license错误，那就可以使用了<br><strong>note:每次虚拟机打开后都要输入<code>lmg_synopsys</code></strong><br><strong>note:我们最好还要打开/home/synopsys/scl/2018.06/admin/license，查看license.dat文件，查看前两行是否正确：</strong></p><pre class="line-numbers language-none"><code class="language-none">SERVER localhost.localdomain 000c2967fe8c 27000DAEMON snpslmd &#x2F;home&#x2F;synopsys&#x2F;scl&#x2F;2018.06&#x2F;linux64&#x2F;bin&#x2F;snpslmd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次感谢公众号“芯王国”提供的支持。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcs </tag>
            
            <tag> verdi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="posts/a9a8.html"/>
      <url>posts/a9a8.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3cfa6f488a9852c70c93260707bfbc98f86a6a367ed4f570c11c738b7f348703">901b05b71b6ef9410c890050abab0ca53675009af90183757c1c8cd406448435a81865033556ecd4bf5218b6d1782603ff5b7dd18cdd5c4aa34f3728d3c3070bd98797c1c450a17b480092fdb3e7e877a1a584c888f19458b0ee6fbd50f4ac2588e94f7a3f08e01979df4d13c44aa933cd1d10704a410af38ab2f92f240d58a5e3ccb78c8444a07ccf96cc35493cf39b5d6fcd012db045c1b83e58e80765c3b2d131c3be48c4533dfad408cf87892374556ca967030335260fae07f1746d190f21699937cc91c2d6cfb5791642dac4188d2da774e6e9d72e77de37f06928b89c235ae84debdd6add8242f9b28ff6c5fae574d96dd3600ef6bb8d3571c4291bf9666ec0adf04ff48e5e05941afec2f93884b63fe38b01b9079b20964b23ea28e609a10cff7a66c3eb57d9730d1c9ec466b4b149893a8f0d5905ef40b0788dd442</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">亲，密码输入就可以看到内容了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 水笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨时钟域问题解决</title>
      <link href="posts/1635.html"/>
      <url>posts/1635.html</url>
      
        <content type="html"><![CDATA[<p>当信号产生于一个时钟域，并穿过该时钟域边界，作用于另一时钟域时，称该信号为跨时钟信号，由<br>此引发的一系列问题称之为 CDC(clock domain crossing, 简称 CDC)问题。</p><h2 id="跨时钟域风险"><a href="#跨时钟域风险" class="headerlink" title="跨时钟域风险"></a>跨时钟域风险</h2><h3 id="1-亚稳态"><a href="#1-亚稳态" class="headerlink" title="1. 亚稳态"></a>1. 亚稳态</h3><blockquote><p>因为进入的数据未能满足触发器的建立时间和保持时间，触发器的输出在一段时间内无法保持一个确定的状态。如下图1所示，clkA和clkB为不同时钟，第一个触发器输出在DFF2的建立时间和保持时间内不断变化，导致DFF2的输出有误，上下动弹甚至出错，出现了亚稳态现象。图2所示为出现亚稳态时的时序图。<br><img src="https://i.loli.net/2021/03/15/h34k7PvNCpzmdQG.png" alt="图1 跨时钟域电路"><br><img src="https://i.loli.net/2021/03/15/Tq23EIWOPgizdZV.png" alt="图2 亚稳态时序图"></p></blockquote><h3 id="2-数据丢失"><a href="#2-数据丢失" class="headerlink" title="2. 数据丢失"></a>2. 数据丢失</h3><blockquote><p>当数据从快时钟域进入慢时钟域时，会出现慢时钟域没有采样到快时钟域的信号，从而出现数据丢失的情况，进而导致系统出现故障。如下图所示，快时钟域 clockA 输出脉冲信号 Q1 到慢时钟域 clockB，在右侧时序图中可以看到此时 clockB 时钟根本没有采样到该脉冲信号。<br><img src="https://i.loli.net/2021/03/15/AXxLsgfdQHNhuDq.png" alt="图3 数据丢失电路"><br><img src="https://i.loli.net/2021/03/15/JGKYdrixkNeQ4yC.png" alt="图4 电路时序图"></p></blockquote><h2 id="跨时钟域处理"><a href="#跨时钟域处理" class="headerlink" title="跨时钟域处理"></a>跨时钟域处理</h2><h3 id="1-两级同步"><a href="#1-两级同步" class="headerlink" title="1. 两级同步"></a>1. 两级同步</h3><blockquote><p>两级同步就是我们常说的“打两拍”，这可以有效降低亚稳态出现的概率。<strong>两级同步处理只适合单比特电路</strong>。<br>下图所示为两级同步原理图，图中 DB1 是第一个触发器的输出，Dout 是第二个触发器的输出。Dout<br>用来避免亚稳态信号传递到其他后续电路中，一旦同步后的信号有机会稳定下来，就会把信号传递出去。<br>两个触发器之间不加任何逻辑，可以为信号稳定争取足够的时间。<br><img src="https://i.loli.net/2021/03/15/OIjBSzoPv4t8D36.png" alt="图5 两级同步电路"><br><img src="https://i.loli.net/2021/03/15/xszneAW2wJZ4EcK.png" alt="图6 电路时序图"></p></blockquote><h3 id="2-信号展宽"><a href="#2-信号展宽" class="headerlink" title="2. 信号展宽"></a>2. 信号展宽</h3><blockquote><p>信号展宽主要是解决单比特信号<strong>从快时钟域跨越到慢时钟域</strong>时产生信号丢失风险。在快时钟域将跨时<br>钟域信号至少展宽成慢时钟域时钟周期的两倍，使得跨时钟域信号对于目的时钟域来说是一种电平信号。<br>如下图所示，左侧红色椭圆圈内是展宽逻辑，这里仅做示意，只展宽成发送时钟域的两个时钟周期。<br><img src="https://i.loli.net/2021/03/15/Leu7brUD8Pd14Mo.png" alt="图8 信号展宽电路图及时序图"></p></blockquote><h3 id="3-格雷码"><a href="#3-格雷码" class="headerlink" title="3. 格雷码"></a>3. 格雷码</h3><blockquote><p>格雷码的独特之处在于相邻两数变换的时候只有1个bit发生改变，通常用于异步fifo的地址传递。所以对于总线的数据，在跨时钟传递前应该进行格雷码转换，然后再传递出去。<br><img src="https://i.loli.net/2021/03/15/S9pR5iBJU87naXs.png" alt="图9 格雷码转换电路图"></p></blockquote><h3 id="4-握手电路"><a href="#4-握手电路" class="headerlink" title="4. 握手电路"></a>4. 握手电路</h3><blockquote><p><strong>note：仅适用于快时钟域向慢时钟域的数据传输</strong><br>握手电路的步骤是：</p></blockquote><ol><li>源时钟域向目的时钟域发送req信号和数据信号</li><li>目的时钟域接收到req和数据信号后，会回发一个ack信号</li><li>源时钟域接收到ack信号后会拉低req信号，整个数据交换完成<br><img src="https://i.loli.net/2021/03/15/top1x4SuA7z8d6m.png" alt="图10 握手电路原理图"></li></ol><p><strong>note: req信号和ack信号要在对方时钟域进行两级同步</strong><br><img src="https://i.loli.net/2021/03/15/vm1lGxXCg4FwiT2.png" alt="图11 握手电路时序图"></p><h3 id="5-异步fifo"><a href="#5-异步fifo" class="headerlink" title="5. 异步fifo"></a>5. 异步fifo</h3><blockquote><p>一般情况下，基本会采用异步fifo传递数据，不受任何限制。但是异步fifo非常消耗资源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDC </tag>
            
            <tag> verilog </tag>
            
            <tag> IC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>modelsim使用到的一些tcl脚本</title>
      <link href="posts/5e6f.html"/>
      <url>posts/5e6f.html</url>
      
        <content type="html"><![CDATA[<p>日常modelsim仿真，每次都需要建立工程，添加波形，很是麻烦，于是我就上网搜了一下，总结写了一点脚本来自动编译仿真代码文件。菜鸟学习中，写得不当，还请指正。</p><h2 id="常用指令简介"><a href="#常用指令简介" class="headerlink" title="常用指令简介"></a>常用指令简介</h2><blockquote><p>vlib work :创建名叫work的工作库<br>vmap work work : 映射逻辑库名work到指定的目录<br>vlog test.v :编译名叫test的verilog文件<br>vcom test.vhd :编译名叫test的vhdl文件<br>vsim -voptargs=+acc -L altera_mf test: 仿真test文件，-L表示使用altera库<br><code>add wave /*</code> : 将所有信号waveform dump出来<br>quit -sim : 停止仿真<br>run 10ms :运行10个ms</p></blockquote><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><blockquote><ol><li>创建一个名叫run的文本文档，将后缀名改为.bat<br>填写内容： </li></ol></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">#C:\modeltech64_10.5\win64\modelsim -do mrun.do#用modelsim仿真则注释下面,根据modelsim安装路径填写上面路径C:\questasim64_10.6c\win64\questasim -do mrun.do#用questasim仿真则注释上面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后关闭</p><blockquote><ol start="2"><li>创建一个名叫mrun的文本文档，将后缀名改为.do<br>填写内容;</li></ol></blockquote><pre class="line-numbers language-none"><code class="language-none">.main clear#清空命令行vlib workvmap work workvlog altera_mf.vvlog filelist.sv#大型工程中，文件众多，可以在filelist中include所有文件#也可以换成vlog src&#x2F;*.v，这需要所以代码放进同一文件夹vsim -novopt -voptargs&#x3D;+acc work.dma_test_top#使用vopt进行设计优化，常与+acc配合使用#vsim用来仿真顶部模块，一般是tb文件，例如上面换成work.test_tbadd log -r &#x2F;*#添加日志，方便仿真中每次添加信号后能自动显示其值，不用重新rundo wave.dorun 10ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后关闭</p><blockquote><ol start="3"><li>创建一个名叫wave的文本文档，将后缀名改为.do<br>填写内容：</li></ol></blockquote><pre class="line-numbers language-none"><code class="language-none">add wave –hex &#x2F;top&#x2F;clk#根据信号引脚填写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为什么要另创建一个wave文件，而不是直接写在mrun.do里，是方便在波形展示界面添加需要查看的信号后可以点击保存信号列表文件，然后覆盖wave文件<br><img src= "/img/modelsim/wave.png" width= "100%"></p><blockquote><ol start="4"><li>filelist文件编写</li></ol></blockquote><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">&#96;include  &quot;.&#x2F;..&#x2F;env&#x2F;ram&#x2F;ram_400_128.v&quot; &#x2F;&#x2F;路径要使用相对路径，本工作目录是和work文件夹在同一目录&#96;include  &quot;.&#x2F;..&#x2F;env&#x2F;ram&#x2F;ram_400_128_add_csn.v&quot;&#x2F;&#x2F; .&#x2F;表示在同一路径   ..&#x2F;表示返回上一目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> modelsim </tag>
            
            <tag> tcl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcl快速入门</title>
      <link href="posts/cb9b.html"/>
      <url>posts/cb9b.html</url>
      
        <content type="html"><![CDATA[<p>TCL是一种很通用的脚本语言，功能强大。最早称为“工具命令语言””Tool Command Language”，但是目前已经不是这个含义，不过我们仍然称呼它TCL，发音为”tickle”。TCL经常被用于快速原型开发，脚本编程，GUI和测试等方面。</p><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><blockquote><p>TCL语言使用<code>$ [] \</code>来实现置换功能<br>$: 解释器会把$后面的认为是变量名，将变量置换成他的值，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set a &quot;zhr&quot;; #赋值给aputs $a;#打印结果为zhrputs a;#打印结果为a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>[ ]</code>:[ ]内是一个独立的TCL语句，例：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set a [expr 3 + 4];puts $a;#打印结果是7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>\</code>: 加上\会变成普通字符,例：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">puts &quot;[expr 3 + 4]&quot;;#结果是7，expr是将运算表达式求值puts &quot;\[[expr 3 + 4]]&quot;;#输出结果是[expr 3 + 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其他字符： { }相当于\ 的功能     #起到注释的作用,此处就不举例说明了</p></blockquote><h2 id="变量数组列表"><a href="#变量数组列表" class="headerlink" title="变量数组列表"></a>变量数组列表</h2><blockquote><p>变量定义 set 变量名 变量值，取值 puts $变量名，例：<br><code>set a &quot;i love you&quot;</code><br><code>puts $a</code></p></blockquote><blockquote><p>数组定义 set 数组名（元素名）值，取值 puts $数组名（元素名），例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set cell(name) &quot;zhr&quot;;puts $cell(name)；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用array获取数组信息，例：<br><code>array size cell</code>或者<code>array name cell</code></p><blockquote><p>列表定义 set 列表名 {元素1 元素2}，取值 puts $列表名，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set list &#123;list1 list2 list3&#125;;puts $list;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本人觉得列表和变量的使用方法相同</p><h2 id="列表指令"><a href="#列表指令" class="headerlink" title="列表指令"></a>列表指令</h2><blockquote><p>contact: 合并两列表，例： </p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">contact $list1 $list2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>llength: 返回元素个数，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">llength $list1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>lindex: 返回列表第n个元素，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">lindex $list1 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>lappend: 末尾加入新元素，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">lappend list1 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>lsort: 排序，后面可加参数 -real 按浮点数大小排  -unique 删除重复，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">lsort (real) $list1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><blockquote><p>if语句：和c语言中的if语句功能十分相似，例</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">if &#123; 表达式 &#125; &#123;            #运算;        &#125; else &#123;             #其他运算;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>foreach语句：把列表里第0个元素开始，依次把值赋给变量，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">foreach i $list&#123;  # 把list里的元素依次给iputs $i&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>break语句</p></blockquote><img src="/img/tcl/break.jpg" width = "100%"><blockquote><p>continue语句<br><img src="/img/tcl/continue.png" width = "100%"></p></blockquote><blockquote><p>while语句<br><img src="/img/tcl/while.png" width = "100%"></p></blockquote><blockquote><p>for语句结构：for{initialization} {condition} {increment} {body}，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">for &#123;set i 0&#125; &#123;$i&lt; 10&#125; &#123;incr i&#125; &#123;puts $i;&#125;  #将打印出0到9&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="过程函数"><a href="#过程函数" class="headerlink" title="过程函数"></a>过程函数</h2><img src="/img/tcl/proc.png" width = "100%"><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><blockquote><p>正则表达式是按照字符匹配规则提取出自己需要的字符内容，字符匹配规则如下：<br>正则表达式的\w，是匹配一个字母、数字或下划线，<br>正则表达式的\d,是匹配数字，<br>正则表达式的\s，用来匹配空格，<br>正则表达式的<code>.</code>,用来匹配任一字符，<br>正则表达式的<code>*</code>用来进行零次或多次匹配，<code>+</code>用来一次或多次匹配，<code>?</code>用来零次或一次匹配，<br>正则表达式的<code>^</code>用来表示字符串开头，<code>$</code>表示字符串结尾。</p></blockquote><p>我们使用正则匹配指令regexp来进行正则匹配。例：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">regexp &#123;\s(\d+).*&#125; &quot;snow is 30 years old&quot; total age puts $total#输出30 years oldputs $age#输出30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><blockquote><p>文本处理在日常生活中十分常用，tcl脚本中用于文本处理的一般是open,gets,close;例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set f01 [open &quot;fix.tcl&quot; w];# 命令表示 打开或者新建一个文件“fix.tcl”，并将其 file ID 设置为 f01，后续就以这个 file ID 来操作这个文件；puts  $f01 &quot;size_cell $cel_name $ref_name&quot; ;#这条命令表示将这个字符串写入文件 fix.tcl，并自动追加换行符；close $f01 ;#对文件操作完成后，需要将其关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="posts/b859.html"/>
      <url>posts/b859.html</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。笔者写这篇文章主要是写给自己看，熟能生巧，也顺便推广一波markdown。</p><span id="more"></span><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><blockquote><p>一个#表示一级标题，两个表示二级标题，最多可使用6个#，代码如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 一级标题## 二级标题### 三级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>可以使用<code>**加粗**</code>显示<br>使用<code>*斜体*</code>显示<br>使用<code>***加粗斜体***</code>显示<br>使用删除线<code>~~删除线~~</code>显示<br>展示效果如下：</p></blockquote><blockquote><p><strong>加粗</strong><br><em>斜体</em><br><em><strong>加粗斜体</strong></em><br><del>删除线</del></p></blockquote><h2 id="2-图片"><a href="#2-图片" class="headerlink" title="2.图片"></a>2.图片</h2><blockquote><p>代码格式：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">![alt 属性文本](图片地址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例来说：</p><pre class="line-numbers language-none"><code class="language-none">![龙猫](https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;15&#x2F;LCEZXoG953nzxpc.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果图片地址为本地，就是</p><pre class="line-numbers language-none"><code class="language-none">![龙猫](&#x2F;img&#x2F;markdown&#x2F;cat.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果展示：<br><img src="https://i.loli.net/2021/03/15/LCEZXoG953nzxpc.jpg" alt="龙猫"></p><blockquote><p>markdown不能改变图片大小，可以使用普通的 <code>&lt;img&gt;</code> 标签<code>&lt;img src=&quot;/img/markdown/cat.png&quot; width=&quot;50%&quot;&gt;</code><br>效果展示：</p></blockquote><img src="/img/markdown/cat.png" width="50%"><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><blockquote><p>一般可以选择在代码前使用 4 个空格或者一个制表符（Tab 键）。<br>又或者在代码上下一行使用```,<br>本人觉得第二种方便使用，前一种不知是不是我方法问题，无法奏效<br>例：</p></blockquote><pre class="line-numbers language-md" data-language="md"><code class="language-md">&#96;&#96;&#96;printf(&quot;i love you&quot;);&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>还有一种，段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#96;printf(&quot;i love you&quot;);&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h2><blockquote><p>代码格式：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">[链接名称](链接地址)或者&lt;链接地址&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：<code>这是我的[博客地址](https://yjgcszhr.github.io/)</code></p><blockquote><p> 效果就是：<br>    这是我的<a href="https://yjgcszhr.github.io/">博客地址</a></p></blockquote><h2 id="5-区块和列表"><a href="#5-区块和列表" class="headerlink" title="5.区块和列表"></a>5.区块和列表</h2><blockquote><p>区块是在段落开头使用<code>&gt;</code>，并空一格<br> 列表使用<code>星号(*)、加号(+)或是减号(-)</code>作为列表标记，或者<code>数字并加上 . 号</code>表示 </p></blockquote><pre class="line-numbers language-none"><code class="language-none"> &gt; 区块中使用列表&gt; 1. 第一项&gt;&gt; 2. 第二项&gt; + 第一项&gt; - 第二项&gt; * 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果展示：</p><blockquote><p>区块中使用列表</p><ol><li>第一项<blockquote><ol start="2"><li>第二项</li></ol></blockquote></li></ol><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/3eeb.html"/>
      <url>posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
