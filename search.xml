<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AMBA总线(5)——AHB总线</title>
      <link href="posts/f147.html"/>
      <url>posts/f147.html</url>
      
        <content type="html"><![CDATA[<p>AHB总线（Advanced High-performance Bus）是AMBA（Advanced Microcontroller Bus Architecture） 片上总线体系的一部分。 在SOC芯片中，AHB总线主要应用于对性能要求较高的组件之间互联，如用于CPU和片内高速RAM、 Nand Flash、 DMA、 Bridge之间互联。</p><p>完整的AHB总线由四个部分组成：</p><p>① AHB主设备Master； 发起一次读/写操作；某一时刻只允许一个主设备使用总线；</p><p>② AHB从设备Slave； 响应一次读/写操作；通过地址映射来选择使用哪一个从设备；</p><p>③ AHB仲裁器Arbiter； 允许某一个主设备控制总线；</p><p>④ AHB译码器Decoder； 通过地址译码来决定选择哪一个从设备；<br>其结构图如下：<br><img src="/img/ahb/z1.png"></p><p>AHB总线的信号都是以H开头，以区别其他的AMBA总线信号<br><img src="/img/ahb/z2.png" alt="master 信号"><br><img src="/img/ahb/z3.png" alt="slave 信号"></p><table><thead><tr><th>信号名</th><th>信号源</th><th>信号功能</th></tr></thead><tbody><tr><td>HCLK</td><td>clock source</td><td>总线时钟信号</td></tr><tr><td>HRESETn</td><td>reset controller</td><td>系统reset信号，低电平有效</td></tr><tr><td></td><td></td><td></td></tr><tr><td>HADDR</td><td>master</td><td>地址总线</td></tr><tr><td>HTRANS</td><td>master</td><td>传输类型，2比特，NONSEQUENTIAL, SEQUENTAL, IDLE 或者BUSY</td></tr><tr><td>HSIZE</td><td>master</td><td>每一个transfer传输的数据大小。以字节为单位</td></tr><tr><td>HBURST</td><td>master</td><td>猝发类型，一共有8种</td></tr><tr><td>HPROT</td><td>master</td><td>保护控制信号，一般不用</td></tr><tr><td>HWDATA</td><td>master</td><td>写数据信号</td></tr><tr><td>HSELx</td><td>decoder</td><td>slave选择信号</td></tr><tr><td>HRDATA</td><td>slave</td><td>读数据信号</td></tr><tr><td>HREADY</td><td>slave</td><td>当这个信号为高时，表示当前transfer完成。</td></tr><tr><td>HRESP</td><td>slave</td><td>响应信号，四种：OKAY，ERROR，RETRY和SPLIT</td></tr><tr><td>下面是仲裁器的信号</td><td></td><td></td></tr><tr><td>HBUSREQx</td><td>master</td><td>master给仲裁器的请求获得总线使用权的请求信号</td></tr><tr><td>HLOCKx</td><td>master</td><td>总线锁定信号</td></tr><tr><td>HGRANTx</td><td>arbiter</td><td>授权信号，会传送给每一个master</td></tr><tr><td>HMASTER</td><td>arbiter</td><td>仲裁器为每一个master分配的ID</td></tr><tr><td>HMASTLOCK</td><td>arbiter</td><td>当前的master正在执行Locked操作</td></tr><tr><td>HSPLITx</td><td>slave</td><td>这个信号是具有SPLIT操作的slave提供</td></tr></tbody></table><h2 id="AHB通信流程"><a href="#AHB通信流程" class="headerlink" title="AHB通信流程"></a>AHB通信流程</h2><p>有需要占用总线的Master向arbiter发出请求，arbiter授权给指定的master。任一时间周期只有一个master可以接入总线，对其指定的slave进行读写操作。      获得授权的总线开始AHB传输，首先发出地址和控制信号，提供地址信息、传输方向、带宽和burst类型。总线统一规划slave的地址，译码器根据地址和控制信号确定哪个slave与master进行数据通信。数据传输通过数据总线完成。为避免出现三态总线，AHB将读写总线分开，写数据总线用于从master到slave的数据传输，读数据总线用于从slave到master的数据传输。每次传输包括一个地址和控制周期，一个或多个数据周期。地址和控制周期不能被扩展，因此slave必须在一个周期内采样地址信号。数据周期可以通过HREADY信号扩展，但HREADY为低时给传输加入一个等待状态以使slave获得额外的时间来提供或采样数据，另外slave通过响应信号HRESP反映传输状态。 </p><p> 1. AHB的猝发类型</p><p>AHB一共有8种类型的传输模式，由HBURST[2:0]来决定，这个和axi总线有些区别，axi总线是由两个信号控制。</p><table><thead><tr><th>HBURST[2:0]</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>000</td><td>SINGLE</td><td>单一传输，一次只有一个地址和控制信号，一组数据</td></tr><tr><td>001</td><td>INCR</td><td>次数不限的递增burst传输。地址根据每拍数据的大小递增，可以传输任意次数。唯一的限制是地址不能超过1K边界</td></tr><tr><td>010</td><td>WRAP4</td><td>4拍的回环burst传输。一共传4拍，地址会在地址边界回环。地址边界根据burst传输的次数和每次传输的数据大小来计算</td></tr><tr><td>011</td><td>INCR4</td><td>4拍的递增burst传输。一共传4拍，地址根据每一拍的数据大小递增</td></tr><tr><td>100</td><td>WRAP8</td><td>8拍的回环burst传输</td></tr><tr><td>101</td><td>INCR8</td><td>8拍的递增burst传输</td></tr><tr><td>110</td><td>WRAP16</td><td>16拍的回环burst传输</td></tr><tr><td>111</td><td>INCR16</td><td>16拍的递增burst传输</td></tr></tbody></table><p>2、传输类型<br>HTRANS[1:0] 进行一次传输时的传输类型，这个信号由master根据自己要进行的传输类型生成的控制信号。一共4种类型</p><table><thead><tr><th>HTRANS</th><th>响应</th><th>描述</th></tr></thead><tbody><tr><td>00</td><td>IDLE</td><td>告知slave当前总线处于空闲状态，没有有效的transaction在进行，那么此时就算slave被使能，也不会从总线上获取任何的数据信号。如果此时salve被选中，那么每一个IDLE周期slave都要通过HRESP[1:0]返回一个OKAY响应（见HRESP）</td></tr><tr><td>01</td><td>BUSY</td><td>如果slave收到了这个信号，表面当前的master正在进行一个burst传输但是在当前周期不能立刻给出下一次要传输的数据，这时slave不会从总线上收取数据而是等待，并且通过HRESP[1:0]返回一个OKAY响应。需要注意的是，这个transfer需要给出下一拍的地址和控制信号，尽管slave不会去采样。</td></tr><tr><td>10</td><td>NONSEQ</td><td>Salve收到这个信号时，表示当前是一个single transfer（就是只传输一次）或者是burst 传输的第一个transfer。此时总线上的地址信号和控制信号与之前的毫不相干。可以理解为一个新的transaction的开始。</td></tr><tr><td>11</td><td>SEQ</td><td>这个信号只有在burst传输中出现。当slave收到这个信号时，表明当前的transfer是一个bursttransaction中的某一拍。这时，总线上的控制信号应当与之前的保持一致，地址视情况递增或者回环。（这些信号其实是由master决定的，slave不用考虑，只需要单方面接收即可）</td></tr></tbody></table><p>直接上时序图：<br><img src="/img/ahb/z4.png" alt="slave 信号"></p><p>3、传输响应<br>HRESP由slave产生，用于对主机传输的响应。<br>|HRESP[1]|    HRESP[0]    |响应    |描述|<br>|—-|—-|—-|—-|<br>|0    |0|    OKAY    |当 HREADY 为高表示传输已经成功完成。 OKAY 响应也被用来插入任意一个附加周期，当 HREADY 为低时，优先给出其他三种响应之一。|<br>|0|    1    |ERROR    |该响应表示发生了一个错误。错误条件应该发信号给总线主机以便让主机意识到传输失败。一个错误条件需要双周期响应。|<br>|1|    0    |RETRY|    RETRY（重试）信号表示传输并未完成，因此总线主机应该重试传输。主机应该继续重试传输直到完成为止。要求双周期的 RETRY 响应。|<br>|1    |1    |SPLIT    |传输并未成功完成。总线主机必须在下一次被授予访问总线时重试传输。当传输能够完成时从机将请求代替主机访问总线。要求双周期的 SPLIT 响应。|</p><p>仅有 OKAY 响应可以在单个周期里给出。 ERROR、 SPLIT 和 RETRY 响应需要至少两个周期。为了完成这些响应中的任意一个那么在倒数第二个（最后一个的前一个）周期从机驱动 HRESP[1： 0]以表示 ERROR、 RETRY 或者 SPLIT 并同时驱动 HREADY 为低以给传输扩展一个额外的周期。在最后一个周期 HREADY 被驱动为高电平以结束传输，同时HRESP[1： 0]保持驱动以表示 ERROR、 RETRY 或者 SPLIT。<br>如果从机需要两个以上的周期以提供 ERROR、 SPLIT 或者 RETRY 响应那么额外的等待状态可能会在传输开始时被插入。在这段时间 HREADY 信号将为低电平同时响应必须被设为 OKAY。</p><p>需要双周期响应是因为总线通道的本质特征。在从机开始发出 ERROR、 SPLIT 或者RETRY 中任何一个响应时接下来传输的地址已经广播到总线上了。双周期响应允许主机有足够的时间来取消该地址并且在开始下一次传输之前驱动 HTRANS[1： 0]为空闲传输。<br>对于 SPLIT 和 RETRY 响应接下来的传输必须取消因为在当前传输完成之前禁止下一次传输发生。然而，对于 ERROR 响应，由于当前传输不被重复，所以可以选择完成接下来的传输。<br>下图表示了一次RETRY操作的例子。</p><p><img src="/img/ahb/z5.png"></p><p>4、总线请求与制裁<br>仲裁机制用来确保任意时刻只有一个主机能够访问总线。仲裁器的功能是检测许多不同的使用总线的请求和决定当前请求总线的主机中哪一个的优先级最高。仲裁器也接收来自从机需要完成 SPLIT 传输的请求。</p><p>总线主机使用 HBUSREQx 信号来请求访问总线并且可以在任何周期请求总线。仲裁器将在时钟的上升沿采样（主机的）请求然后使用内部优先级算法来决定哪个主机将会下一个获得访问总线。<br>如果主机请求锁定访问（总线）,那么主机也必须断言 HLOCKx 信号来提示仲裁器其它主机不应该被授予总线。<br>当一个主机被授予总线并且正在执行一个固定长度的突发,那么就没有必要继续请求总线以便完成传输。仲裁器监视突发的进程并且使用 HBURST[2： 0]信号来决定主机请求了多少个输入。如果主机希望在当前正在进行的传输之后执行另一个突发那么主机需要在突发中重新断言请求信号。<br>如果主机在一次突发当中失去对总线的访问那么它必须重新断言 HBUSREQx 请求线以重新获取访问总线。<br>对未定长度的突发主机应该继续断言请求直到已经开始最后一次传输。在未定长度的突发结束时仲裁器不能预知何时改变仲裁。<br>对于主机而言有可能当它未申请总线时却被授予总线。这可能在没有主机请求总线并且仲裁器将访问（总线）授予一个默认的主机时发生。因此，如果一个主机并没请求访问总线那么它驱动传输类型 HTRANS 来表示空闲传输显得很重要。<br>仲裁器通过断言适当的 HGRANTx 信号来表示请求总线的主机中哪个是当前优先级最高的。当前传输完成后，由 HREADY 为高时所表示，那么主机将被授予（总线）并且仲裁器将改变 HMASTER[3： 0]信号来表示总线主机序号。<br>下图表示了当所有传输都为零等待状态并且HREADY信号为高时的处理过程。<br><img src="/img/ahb/z6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA总线 </tag>
            
            <tag> AHB总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MKA密钥协商</title>
      <link href="posts/fc50.html"/>
      <url>posts/fc50.html</url>
      
        <content type="html"><![CDATA[<p>MKA（MACsec Key Agreement protocol）是用于 MACsec 数据加密密钥的协商协议。该部分用于生成macsec数据所需要的SAK，并对SAK进行分发。</p><h2 id="协商流程"><a href="#协商流程" class="headerlink" title="协商流程"></a>协商流程</h2><p>1、在同一个安全链接关联 CA 成员 CA(a)和 CA(b)上，用户静态配置相同的(CKN，CAK)<br>产生的（ICK，KEK）是一样的，用于后续发布 SAK 对其本身进行加密，防止 SAK 明文<br>传递过程中泄密；<br>2、在 Key Server 基于用户配置的（CKN，CAK）会生成 SAK，并且在本地安装 SAK，<br>用于 Key Server 端收发数据报文的加解密；<br>3、Key Server 将 SAK 发布给对端 Supplicant 时，通过 KEK 加密 SAK 密钥本身，由<br>ICK 通过某种算法生成 ICVs 用于校验报文的完整性，在 Key Server 上将 ICVs 值放在<br>MKA协议报文尾部，将经过KEK加密的SAK一起通过MKA协议报文发送给Supplicant；<br>4、Supplicant 接收到 MKA 协议报文时，根据其中的 CKN 查找 CAK 和 ICK，如果没有<br>查找到则认为不是来自相同的 CA 并丢弃，查找到之后对 MKA 报文主体进行 ICV 计算<br>得到 ICVc，如果与报文中的 ICVs 不相同，则认为报文被修改（MKA 报文中的 CKN 和<br>ICVs 没有经过 KEK 加密）；<br>5、经过 ICV 校验通过之后，使用 KEK 解密出 SAK，Supplicant 进行 SAK 安装，用于<br>Supplicant 端收发数据报文的加解密。<br><img src="/img/mka/i1.png"></p><p>两端设备预先配置好约定好的CKN、CAK ，然后采用 KDF 算法生成 SAK、KEK、ICK、ICV，Key Server 和 Supplicant 两边配置（CKN，CAK）生成 KEK、ICK、ICV，<br>Key Server 同时生成 SAK 并且在本地安装，然后 Key Server 将 SAK 用 KEK 加密，将加密后的 SAK 通过 MKA 协议报文发送给 Supplicant，MKA 协议报文中尾部包含 ICV 字段。<br>Supplicant 收到协议报文通过 ICV 检验之后，将 SAK 密钥解密并在 Supplicant 上安<br>装，这样 Key Server 和 Supplicant 两边转发层面都用相同的 SAK 密码，可以对收发<br>的数据报文进行加解密通信。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1、KDF-密钥推导函数"><a href="#1、KDF-密钥推导函数" class="headerlink" title="1、KDF(密钥推导函数)"></a>1、KDF(密钥推导函数)</h3><p>公式为Output = KDF (Key, Label, Context, Length)<br>此处input:<br>Key： a key derivation key of 128 or 256 bits<br>Label：a string identifying the purpose of the keys derived using this KDF，字符串形式,<br>Context：a bit string that provides context to identify the derived key ，字符串形式<br>Length：the length of the output in bits encoded in two octets with the most significant octet first<br>此处Output: a Length-bit derived value<br><strong>Note: label,context这些字符串有规定的十六进制表达方式，方便后期进行公式计算。比如“IEEE8021 ICK”的十六进制表达是49454545383032312049434b，具体请参照802.1x协议。</strong></p><p>参数h：the length of the output of the PRF（伪随机函数） in bits，即输出的比特位数，此处的函数为AES-CMAC-128 和AES-CMAC-256 。当用于加密的密钥是128位选前者，256位选后者。</p><p>迭代次数(Length + (h–1))/h </p><p>For   i = 1 to 迭代次数<br>result =  result | PRF(Key, i | Label | 0x00 | Context | Length) </p><p>return first Length bits of result, and securely delete all unused bits，即当length为128时，取result的前128位。<br><strong>Note:此处的”|”是指把i,label,0x00,context,length连接在一起。</strong></p><h3 id="2、算出ICK，"><a href="#2、算出ICK，" class="headerlink" title="2、算出ICK，"></a>2、算出ICK，</h3><p>ICK（ICV Key，ICK 密钥）由 CAK 根据算法推导产生，只用于计算 MKA 协议层面报文<br>的 ICV 值。<br>ICK = KDF(Key, Label, Keyid, ICKLength)<br>其中<br>Key = CAK<br>Label = “IEEE8021 ICK”<br>Keyid = CKN的前16字节,the first 16 octets of the CKN, with null octets appended to pad to 16 octets if necessary<br>ICKLength =（2个字节）表示ICK长度，128表示128位，256表示256位 </p><h3 id="3、算出KEK"><a href="#3、算出KEK" class="headerlink" title="3、算出KEK"></a>3、算出KEK</h3><p>KEK（Key Encrypting Key，密钥加密密钥）由 CAK 根据算法推导产生，用于加密 SAK，<br>通过 MKA 密钥协议报文将 SAK 密钥发送给同一个 CA 内的参与者，防止用于数据加密<br>的 SAK 在传输过程中被窃取。<br>KEK = KDF(Key, Label, Keyid, KEKLength)<br>其中<br>Key = CAK<br>Label = “IEEE8021 KEK”<br>Keyid = CKN的前16字节，the first 16 octets of the CKN, with null octets appended to pad to 16 octets if necessary<br>KEKLength =（2个字节）表示KEK长度，128表示128位，256表示256位 </p><h3 id="4、算出SAK"><a href="#4、算出SAK" class="headerlink" title="4、算出SAK"></a>4、算出SAK</h3><p>SAK（Secure Association Key，安全关联密钥）由 CAK 根据算法推导产生，用于加密<br>安全通道间传输的数据。MKA 对每一个 SAK 可加密的报文数目有所限制，当使用某<br>SAK 加密的 PN 耗尽，该 SAK 会被刷新。</p><p>SAK = KDF(Key, Label, KS-nonce | MI-value list | KN, SAKlength)<br>其中<br>Key = CAK<br>Label = “IEEE8021 SAK”<br>KS-nonce = a nonce of the same size as the required SAK, obtained from an RNG each time an SAK is generated. 由密钥服务器系统随机数生成器生成，长度与SAK一样。<br>MI-value list = 所有参与者的MI值的连接。MI（Member Identifier）是成员标识符，<br>KN = 由密钥服务器指定的32位的key number。<br>SAKlength =（2个字节）表示SAK长度，128表示128位，256表示256位 </p><h3 id="5、计算ICV"><a href="#5、计算ICV" class="headerlink" title="5、计算ICV"></a>5、计算ICV</h3><p>ICV（Integrity Check Value，完整性校验值）是报文完整性检验值，在报文发送端，通<br>过某种算法对报文数据单元计算产生一个检验值，将此检验值放在报文的尾部，报文接<br>收端通过相同算法得到 ICV 值与报文携带的 ICV 进行比对，如果这两个 ICV 相同说明报<br>文没有被修改，否则该报文被丢弃，保证了报文的数据完整性。<br>ICV = AES-CMAC(ICK, M, 128)<br>M = DA + SA + (MSDU – ICV)<br>其中DA是目的地MAC地址，SA是源MAC地址，MSDU是包含SAK的EOPL-MKA报文信息.</p><h3 id="6、EAPOL-MKA报文"><a href="#6、EAPOL-MKA报文" class="headerlink" title="6、EAPOL-MKA报文"></a>6、EAPOL-MKA报文</h3><p>服务器通过EAPOL-MKA报文向CA群员分发已加密过的SAK.</p><p>报文由DA,SA, MPDU（最后部分加上icv）构成。<br>MPDU结构如下<br> <img src="/img/mka/i2.png"><br>Protocol version:0x03<br>Packet type: EAPOL-MKA的类型是0000 0101<br>Packet body length: 包长度<br>Packetbody:包内容</p><p>其中packetbody结构如下：<br>如果采用gcm-aes-128对sak加密的话，报文格式如下：<br> <img src="/img/mka/i3.png"><br>其中：<br>Distributed AN：通常设置为0，表示为分发密钥。<br>Confidentiality Offset：保护性偏置，<br>Parameter set body length: 其后报文内容的长度, 采用gcm-aes-128则是28，采用非gcm-aes-128的话则是36.<br>Key Number: SAK的ID<br>AES Key Wrap of SAK：128比特的加密后的SAK</p><p>如果采用非gcm-aes-128对sak加密的话，报文格式如下：<br><img src="/img/mka/i4.png"></p><p>MACsec Cipher Suite：加密套件不是默认的gcm-aes-128，就要填写采用的加密套件的标识符。<br>不同加密套件标识符如下：<br> <img src="/img/mka/i5.png"></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MKA </tag>
            
            <tag> MACSEC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线(4)——axi4总线</title>
      <link href="posts/6229.html"/>
      <url>posts/6229.html</url>
      
        <content type="html"><![CDATA[<p>学完了axi4-stream和axi4-lite总线，我们可以轻松学习标准的axi4总线。axi4总线和axi4-lite总线差不多也有五个独立通道，<br>axi4-lite总线是axi4总线的子集，即axi4-lite的握手机制、独立通道配合等在axi4这儿一样适用。我们现在讲一下axi4的独特之处。</p><h2 id="猝发类型："><a href="#猝发类型：" class="headerlink" title="猝发类型："></a>猝发类型：</h2><p>axi4可支持猝发传输，即一次可以传输多达256个数据。而且每一次猝发传输在完成所有数据传输前不能提前结束，即使数据错误，不想要也要含泪走完整个流程。<br>回卷猝发、递增猝发、固定猝发。所有猝发都不能超过4KB地址边界</p><h3 id="回卷猝发"><a href="#回卷猝发" class="headerlink" title="回卷猝发"></a>回卷猝发</h3><p>猝发长度仅支持2、4、8、16，地址会回卷，地址增加到某个地址后会回到初始地址。</p><h3 id="递增猝发"><a href="#递增猝发" class="headerlink" title="递增猝发"></a>递增猝发</h3><p>每次传输地址会在上一个地址基础上增加,递增幅度与传输宽度相同。适合对于 RAM 等通过地址映射（mapped memory）的存储介质进行读写操作。</p><h3 id="固定猝发"><a href="#固定猝发" class="headerlink" title="固定猝发"></a>固定猝发</h3><p>即每次传输都使用一个地址-初始地址,该模式适合对某个固定地址进行多次数据更新。比如读写fifo.</p><h2 id="读写时序图"><a href="#读写时序图" class="headerlink" title="读写时序图"></a>读写时序图</h2><p>当地址出现在地址总线后，传输的数据将出现在读数据通道上。设备保持VALID 为低直到读数据有效。为了表明一次突发式读写的完成，设备用 RLAST 信号来表示最后一个被传输的数据。<br><img src="/img/axi4/l1.png" alt="AXI4突发读时序"></p><p>主机发送地址和控制信息到写地址通道中，然后主机发送每一个写数据到写数据通道中。当主机发送最后一个数据时，WLAST 信号就变为高。当设备接收完所有数据之后他将一个写响应发送回主机来表明写事务完成。<br><img src="/img/axi4/l2.png" alt="AXI4突发写时序"></p><h2 id="信号线详解"><a href="#信号线详解" class="headerlink" title="信号线详解"></a>信号线详解</h2><p>axi4-lite总线里讲解过的部分信号此处跳过，大家想看的话可以点击这里<a href="https://zhuhr.xyz/posts/60b1.html">axi4-lite总线</a></p><h3 id="全局信号"><a href="#全局信号" class="headerlink" title="全局信号"></a>全局信号</h3><p><strong>ACLK</strong><br><strong>ARESETn</strong> </p><h3 id="写地址通道信号"><a href="#写地址通道信号" class="headerlink" title="写地址通道信号"></a>写地址通道信号</h3><p>主机(master)控制的信号<br><strong>AWVALID</strong> <strong>AWADDR</strong> <strong>AWPROT</strong><br><strong>AWID</strong>:写地址ID。这个信号用于写地址信号组的标记。<br><strong>AWLEN</strong>:猝发长度，给出突发传输中准确的传输个数。在回卷猝发和递增猝发模式有效。<br><strong>AWSIZE</strong>:猝发传输宽度。这个信号用于确定突发传输中每个传输的大小。不能大于总线宽度。有1、2、4、8……128字节可选<br><strong>AWBURST</strong>:猝发类型。<br><strong>AWLOCK</strong>:锁类型。该信号提供了关于传输原子特性的额外信息（普通或互斥访问）。<br><strong>AWCACHE</strong>:缓存类型，建议值为0011。<br><strong>AWREGION</strong>:用于每个写操作的地址通道上的域标识符。</p><p>从机(slave)控制的信号<br><strong>AWREADY</strong></p><h3 id="写数据通道信号"><a href="#写数据通道信号" class="headerlink" title="写数据通道信号"></a>写数据通道信号</h3><p>主机(master)控制的信号<br><strong>WVALID</strong> <strong>WDATA</strong> <strong>WSTRB</strong><br><strong>WLAST</strong>:最后一个数据指示信号<br><strong>WUSER</strong>:xilinx不支持<br>从机(slave)控制的信号<br><strong>WREADY</strong></p><h3 id="写应答通道信号"><a href="#写应答通道信号" class="headerlink" title="写应答通道信号"></a>写应答通道信号</h3><p>主机(master)控制的信号<br><strong>BREADY</strong></p><p>从机(slave)控制的信号<br><strong>BVALID</strong> <strong>BRESP</strong><br><strong>BID</strong>:响应ID,必须与AWID相匹配。</p><h3 id="读地址通道信号"><a href="#读地址通道信号" class="headerlink" title="读地址通道信号"></a>读地址通道信号</h3><p>主机(master)控制的信号<br><strong>ARVALID</strong> <strong>ARADDR</strong> <strong>ARPROT</strong><br><strong>ARID</strong><br><strong>ARLEN</strong><br><strong>ARSIZE</strong><br><strong>ARLOCK</strong><br><strong>ARBURST</strong><br><strong>ARCACHE</strong><br><strong>ARREGION</strong><br>以上信号解析与写地址通道的相类似。</p><p>从机(slave)控制的信号<br><strong>ARREADY</strong></p><h3 id="读数据通道信号"><a href="#读数据通道信号" class="headerlink" title="读数据通道信号"></a>读数据通道信号</h3><p>从机(slave)控制的信号<br><strong>RREADY</strong><br>主机(master)控制的信号<br><strong>RVALID</strong> <strong>RDATA</strong> <strong>RRESP</strong><br><strong>RLAST</strong><br><strong>RID</strong></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA总线 </tag>
            
            <tag> AXI4-full </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线(3)——axi4-lite总线</title>
      <link href="posts/60b1.html"/>
      <url>posts/60b1.html</url>
      
        <content type="html"><![CDATA[<p>学完了AXI4-stream总线，我们继续来学习AXI4—lite总线。虽然同属于AXI4协议，但两者还存在较大差别。<br>AXI4-lite总线是AXI4总线的简化版，仅支持32位或64位数据读写，而且每次只支持一次数据的读写。即猝发长度为1。这一特性限制了它只能用于小数量的数据传输.</p><h2 id="独立通道"><a href="#独立通道" class="headerlink" title="独立通道"></a>独立通道</h2><p>AXI4-lite有五个独立的通道<br>读地址通道(Read address channel AR)<br>读数据通道(Read data channel R)<br>写地址通道(Write address channel AW)<br>写数据通道(Write data channel W)<br>写应答通道(Write response channel B)<br>每个通道都是双向握手机制通信，具体握手流程可参照前文<a href="https://zhuhr.xyz/posts/4372.html">axi4-stream总线</a>所述，<br>那这几种通道如何配合工作完成一次完整的数据通信呢？<br>写数据过程：<br>首先主机发出写地址和控制信号，然后发出一次写数据，最后从机进行写应答。无论发送地址、数据、应答都是双方通过握手协议完成。<br><img src="/img/axi4_lite/e1.png" alt="写数据过程"></p><p>读数据过程：<br>首先主机发出读地址和控制信号，然后从机发送读数据。比起写数据过程，读数据过程少了一个应答环节。<br><img src="/img/axi4_lite/e2.png" alt="读数据过程"></p><h2 id="信号线详解"><a href="#信号线详解" class="headerlink" title="信号线详解"></a>信号线详解</h2><h3 id="全局信号"><a href="#全局信号" class="headerlink" title="全局信号"></a>全局信号</h3><p><strong>ACLK</strong> 全局时钟信号，在上升沿时对信号采样。所有的输入信号都通过上升沿采集，所有的输出信号都在上升沿时变化。<br><strong>ARESETn</strong> 全局复位信号，低电平有效。在复位期间，所有的xxVALID信号必须复位为低电平。其他的信号可以是任意值。</p><h3 id="写地址通道信号"><a href="#写地址通道信号" class="headerlink" title="写地址通道信号"></a>写地址通道信号</h3><p>主机(master)控制的信号<br><strong>AWVALID</strong><br><strong>AWADDR</strong> 地址信号线，传输地址信息。<br><strong>AWPROT</strong> 访问权限信号线，xilinx建议赋值为3’b000.xilinx IP 一般忽略此信号。<br>从机(slave)控制的信号<br><strong>AWREADY</strong></p><h3 id="写数据通道信号"><a href="#写数据通道信号" class="headerlink" title="写数据通道信号"></a>写数据通道信号</h3><p>主机(master)控制的信号<br><strong>WVALID</strong><br><strong>WDATA</strong> 数据信号线，传输数据信息。<br><strong>WSTRB</strong> 数据总线有效字节控制。比如32位的总线，WSTRB等于4’b0010,那么代表WDATA[15:8]中的数据有效。其他无效。如果要求WDATA[31:0]32位全有效，那么WSTRB就应该等于4’b1111.<br>从机(slave)控制的信号<br><strong>WREADY</strong></p><h3 id="写应答通道信号"><a href="#写应答通道信号" class="headerlink" title="写应答通道信号"></a>写应答通道信号</h3><p>主机(master)控制的信号<br><strong>BREADY</strong><br>从机(slave)控制的信号<br><strong>BVALID</strong><br><strong>BRESP</strong> 应答类型。2bit信号<br>OKEY   00 正常访问成功<br>EXOKAY 01 独占访问成功，<strong>AXI4-lite不支持</strong><br>SLVERR 10 从机错误，出现的原因有：FIFO 或者缓冲区溢出主机发起了不支持的传输位宽、尝试向读保护的地址写入数据、超时<br>DECERR 11 解码错误，比如没有从机的地址。</p><h3 id="读地址通道信号"><a href="#读地址通道信号" class="headerlink" title="读地址通道信号"></a>读地址通道信号</h3><p>主机(master)控制的信号<br><strong>ARVALID</strong><br><strong>ARADDR</strong> 地址信号线，传输地址信息。<br><strong>ARPROT</strong> 访问权限信号线，xilinx建议赋值为3’b000.xilinx IP 一般忽略此信号。<br>从机(slave)控制的信号<br><strong>ARREADY</strong></p><h3 id="读数据通道信号"><a href="#读数据通道信号" class="headerlink" title="读数据通道信号"></a>读数据通道信号</h3><p>从机(slave)控制的信号<br><strong>RREADY</strong><br>主机(master)控制的信号<br><strong>RVALID</strong><br><strong>RDATA</strong> 数据信号线，传输数据信息。<br><strong>RRESP</strong> 同写应答信号BRESP</p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMBA总线 </tag>
            
            <tag> AXI4-lite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序优化</title>
      <link href="posts/d915.html"/>
      <url>posts/d915.html</url>
      
        <content type="html"><![CDATA[<p>当综合工具综合一个完整工程后，使用者可以查看时序分析结果，以vivado为例，我们可以看到模块电路的建立时间裕量、保持时间裕量分析，其结果可决定模块电路可以跑到多大时钟频率。如果这些时间裕量为负，那么只能降低时钟频率又或者进行时序优化。</p><h2 id="建立时间问题"><a href="#建立时间问题" class="headerlink" title="建立时间问题"></a>建立时间问题</h2><p>建立时间裕量公式分析前面已经解析过了，建立时间裕量问题很是常见，其出现原因主要是组合逻辑过于复杂冗余，或者电路扇出太大。</p><h3 id="组合逻辑冗余"><a href="#组合逻辑冗余" class="headerlink" title="组合逻辑冗余"></a>组合逻辑冗余</h3><p>组合逻辑复杂冗余会导致逻辑级数过多（逻辑级数是指一个LUT和一个net的延迟），举个例子来说，如果一个逻辑级数延迟0.5ns,那么十级逻辑级数就是5ns，级数越多延迟越大，这肯定会影响模块的工作频率。所以有效降低逻辑级数才能更好的提高时钟频率。怎么做呢？<br>首先找出路径延迟最大的一条path，对于这条路径的组合逻辑进行优化，优化无非这么几种，<br>1、加入寄存器，将冗长的组合逻辑多打几拍，类似于流水线操作。注意在组合逻辑中间处添加寄存器，否则效果不明显。</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">reg [3:0]sum;wire a,b,c,d,e,f;always@(posedge clk) beginsum &lt;&#x3D; a+b+c+d;end <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改后：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">reg [3:0]sum;reg [2:0]sum1;reg [2:0]sum2;wire a,b,c,d,e,f;always@(posedge clk) beginsum &lt;&#x3D; sum1 +sum2;sum1 &lt;&#x3D; a+b;sum2 &lt;&#x3D; c+d;end <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、并行化处理，将大的逻辑块分解成几个小的进行并行处理，例如实现sum= a+b+c+d+e+f;<br>源代码是这样：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">wire [3:0]sum;wire a,b,c,d,e,f;assign sum &#x3D; a+b+c+d+e+f;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们拆解后就可以是这样：</p><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">wire [3:0]sum;wire [1:0]sum1;wire [1:0]sum2;wire [1:0]sum3;assign sum1 &#x3D; a+b;assign sum2 &#x3D; c+d;assign sum3 &#x3D; d+e;assign sum &#x3D; sum1+sum2+sum3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原先5级逻辑被优化成3级，大大减少了延迟。</p><p>3、优化优先级电路，即对于if else语句，第一if else 不能嵌套太多，（即小于等于三层嵌套），第二 如果优先级电路不必须的话，可以采用case语句。</p><h3 id="电路扇出太大"><a href="#电路扇出太大" class="headerlink" title="电路扇出太大"></a>电路扇出太大</h3><p>电路扇出就是该信号驱动下一级信号的个数，一般来说，扇出数目越大，延迟越大。解决的方法就是<br>1、复制电路。例如一个组合逻辑驱动多个寄存器，<br><img src="/img/%E6%97%B6%E5%BA%8F%E4%BC%98%E5%8C%96/h1.jpg"><br>优化后：<br><img src="/img/%E6%97%B6%E5%BA%8F%E4%BC%98%E5%8C%96/h2.jpg"><br>一般推荐模块输出采用寄存器输出，这样情况下复制电路就是多复制几个寄存器。<br>2、使用BUFG<br>通常BUFG是用于全局时钟的资源，可以解决信号因为高扇出产生的问题。但是其一般用于<strong>时钟或者复位</strong>之类扇出超级大的信号，此类信号涉及的逻辑遍布整个芯片，而BUFG可以从全局的角度优化布线。<br>在xdc文件里添加</p><pre class="line-numbers language-none"><code class="language-none">set_property CLOCK_BUFFER_TYPE BUFG [get_nets netName]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、在代码中标注信号属性，规定扇出数目，剩下的交给综合器进行优化。</p><pre class="line-numbers language-none"><code class="language-none">(* max_fanout &#x3D; &quot;3&quot; *)reg  signed [15:0] din_d;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="保持时间问题"><a href="#保持时间问题" class="headerlink" title="保持时间问题"></a>保持时间问题</h2><p>保持时间违例原因只有延时不够，其公式分析前文已经讲过，解决的办法很简单就是插入buffer,要么综合器自己优化插入，要么手动插入。我推荐输入命令set_fix_hold(DC)让综合器自己生成buffer，如果保持时间违例少量的话，可以手动在网表里插入延迟。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC设计 </tag>
            
            <tag> 时序优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>systemverilog学习日记（一）</title>
      <link href="posts/a99d.html"/>
      <url>posts/a99d.html</url>
      
        <content type="html"><![CDATA[<p>IC前端设计需要设计人员编写testbench来进行对模块的初步前仿，一般是用verilog来写，但是verilog语言结构简单，编写一个稍微复杂的仿真环境很是费力，所以systemverilog便被开发设计出来。systemVerilog是一门高级语言，官方描述为：<br>SystemVerilog简称为SV语言，是一种相当新的语言，它建立在Verilog语言的基础上，是 IEEE 1364 Verilog-2001 标准的扩展增强，兼容Verilog 2001，将硬件描述语言（HDL）与现代的高层级验证语言（HVL）结合了起来，并新近成为下一代硬件设计和验证的语言。<br>既可以用作设计又可以用作验证，功能十分强大，所以多学一门systemverilog会让你如虎添翼。笔者本着学无止境的态度，开始接触学习systemverilog.开始吧，一步一个脚印。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="内建数据类型"><a href="#内建数据类型" class="headerlink" title="内建数据类型"></a>内建数据类型</h3><p>什么语言一开始都要从基本数据类型学起，sv也不例外。sv的数据类型像是继承了c语言的很多特色，除了byte 、int、shortint、longint这些c语言里经常看到的，SV还加了logic<br>、bit等。接下我解释一下这些类型怎么个用法。</p><blockquote><p>logic: 只能双状态，0或者1，reg型和wire型综合，只能被单一驱动<br>bit: 四状态，0,1，高阻z，未知x，这个比较常用，可以自由定义位宽，例如</p></blockquote><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">bit b;    &#x2F;&#x2F;单比特bit [15:0] data;&#x2F;&#x2F;16比特数据，无符号rand bit [15:0] r_data;&#x2F;&#x2F; 写testbench时经常会加上rand,用于生成随机化数据。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>byte: 8比特有符号数据<br>int: 32比特有符号数据<br>shortint: 16比特有符号整数<br>longint: 64比特有符号整数</p></blockquote><p><strong>这些都可以用bit来代替，而且Bit是无符号的，bit [7:0] 等于 byte unsigned</strong></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组可分成定宽数组和动态数组，定宽数组又可以分成压缩数组和非压缩数组，</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">bit [7:0] data [0:3] &#x2F;&#x2F;生成位宽8，深度为4的数组,这是非压缩数组&#x2F;&#x2F;也可以这样表达bit [0:3] [7:0]  data;&#x2F;&#x2F;压缩数组，作用类似上面表达bit [0:3] [7:0] barray[3]&#x2F;&#x2F;这个用法我也没见过，书上是这么定义的，其存放示意图如下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>压缩数组的结构是这样的<br><img src="/img/sv1/f1.png" alt="图1"><br><img src="/img/sv1/f2.png" alt="图2"></p><p>动态数据是位宽暂时无法确定的数组，其在声明时使用空的[],在使用时需要调用new[]，同时方括号里要填上数组的宽度，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">int data[];&#x2F;&#x2F;声明动态数组initial begindata&#x3D;new[4];&#x2F;&#x2F;数组宽度为4end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h3><p>sv提供typedef 和 struct来为用户自定义数据类型</p><blockquote><p>struct和typedef用法和c语言的差不多，直接代码解释：</p></blockquote><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">typedef struct &#123;int a,b,c;&#125; usr_data;&#x2F;&#x2F;创建usr_data结构，包括三个int数据typedf int unsigned uint;&#x2F;&#x2F;uint 和 int unsigned等效，下面语句可以直接使用uint<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><p>端口与端口之间的连接一般通过input和output来传输信号线，当这些信号线数目大的时候，信号线连接就会出现很多的问题和麻烦，于是接口interface就被提出，interface的作用就是把一群信号线捆绑成一个接口，里面可以有时钟有复位信号，也有多位宽数据。接口可以被方便引用，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">interface arb_if (input bit clk); logic [1:0] grant,request; logic rst; endinterface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>发没发现接口里的数据类型都是logic,而不是wire,想想什么原因？<br>以上是我们定义了一个接口，接下来展示我们怎么使用它。如果需要用到接口里的某个信号，我们只要写<code>接口名.信号名</code>，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">module test (arb_if arbif);&#x2F;&#x2F;接口名 自定义名always @ (posedge arbif. clk or posedge arbif. rst) begin if (arbif. rst) arbif.grant&lt;&#x3D;2&#39;bOO; else ••• endendmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>PS:接口里的信号必须使用非阻塞赋值</strong></em></p><h3 id="modport"><a href="#modport" class="headerlink" title="modport"></a>modport</h3><p>modport的功能是把interface里的信号分组，选取一些信号作为输入，一些信号作为输出，modport 名（input/output 信号名,…..）例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">interface arb_if (input bit clk); logic [ 1: O] grant, reques 七；logic rst; modport TEST (output request, rst, input grant, clk); modport DUT (input request,rst,clk, output grant);modport MONITOR (input request,grant,rst,clk); endinterface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那我们怎么去用它呢？很简单，就是 <strong>接口名.modport名 自定义接口名</strong> ，例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">module arb (arb_if.DUT arbif); ••• endmodule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="clocking"><a href="#clocking" class="headerlink" title="clocking"></a>clocking</h3><p>每个接口可以有多个时钟块，<code>clocking cb @（posedge clk）</code>的作用是表明我这个区域里的信号只在我这时钟上升沿有效，具体怎么表达例如：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">clocking cb @ (posedge clk) ；／／声明 cboutput request; input grant；endclocking<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>既然学了clocking，那么modport的写法我们又能这么写了：</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">modport TEST (clocking cb, ／／使用 cboutput rst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>怎么用这个接口呢？那就是像套娃一样，怎么套进去的怎么拿出来，</p><pre class="line-numbers language-sv" data-language="sv"><code class="language-sv">program automatic test (arb_if.TEST arbif); &#x2F;&#x2F;program习惯加上automatic,initial begin arbif. cb. request&lt;&#x3D; 2&#39;bOl;   &#x2F;&#x2F;接口里的clocking模块里的信号$display( ＂@%t: Drove req&#x3D; 01&quot;, $time); repeat (2) @arbif.cb;   &#x2F;&#x2F;重复两个clocking模块里的时钟if (arbif.cb.grant! &#x3D;2&#39;b01) $display (&quot;@%t: al: grant! &#x3D; 2&#39;bOl&quot;, $time); end endprogram : test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sytemverilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线（2）——axi4_stream总线</title>
      <link href="posts/4372.html"/>
      <url>posts/4372.html</url>
      
        <content type="html"><![CDATA[<p>AXI4-stream接口连接产生数据的一个主设备和接收数据的一个从设备，用来传播数据流，和其他AXI协议不同的是，AXI4-stream不需要主机提供地址，使用相对方便，当传输单数据时其数据传输时序与第一讲的APB总线就少了个地址信息的，其他大致相同。</p><h2 id="接口信号"><a href="#接口信号" class="headerlink" title="接口信号"></a>接口信号</h2><blockquote><p>ACLK: 系统时钟<br>ARESTEN: 复位信号，低电平有效<br>TVALID: 表示主机正在进行数据传输<br>TREADY: 表示从机已经做好数据接收的准备<br>TDATA: 传输的数据<br>TSTRB: 字节控制信号，按照byte指定data中的哪个byte是地址信息或者数据信息；<br>TKEEP: 字节控制信号，指定data中的哪个byte是字节修饰符，哪个是有效的。<br>TLAST: 表示数据流的最后标志<br>TID: 标识符，表示不同数据流<br>TDEST: 提供路由信息<br>TUSER: 用户自定义信息<br><strong>PS:如果TKEEP引脚不在的话，TSTRB承担指定字节有效的功能</strong></p></blockquote><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><blockquote><p>首先主设备给出数据和控制信息，并拉高TVALID信号，然后等待从机的TREADY信号，一旦TREADY信号为高，数据就开始传输，一般来说，无论TVALID和TREADY谁先到达，只有当TVALID和TREADY信号同时为高时，一次传输才算完成。如果连续多包数据传输的话，TVALID将一直拉高，直到最后一包数据传输，TLAST拉高。传输完成后，TVALID拉低，TLAST拉低。<br>直接放图会更容易理解。以下为TVALID和TREADY握手示意图：<br><img src="/img/axi_stream/d1.png" alt="TVALID在TREADY前握手"><br><img src="/img/axi_stream/d2.png" alt="TVALID在TREADY后握手"><br><img src="/img/axi_stream/d3.png" alt="TVALID和TREADY同时握手"></p></blockquote><p>多次连续传输示意图，<br><img src="/img/axi_stream/d4.png" alt="axi_stream多数据传输"></p><h2 id="修改自定义AXI4-stream-ip核"><a href="#修改自定义AXI4-stream-ip核" class="headerlink" title="修改自定义AXI4-stream ip核"></a>修改自定义AXI4-stream ip核</h2><blockquote><p>官方生成的带有AXI4-stream接口的IP核，是用一个二维数组来存放stream——data，但这不方便读出来进行二次开发，于是我做了一点改动，官方源码部分截图如下<br><img src="/img/axi_stream/d5.png"><br>笔者修改后的源码部分：</p></blockquote><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">   reg  [0 : NUMBER_OF_INPUT_WORDS-1] [C_S_AXIS_TDATA_WIDTH-1:0] data_fifo ;&#x2F;&#x2F; FIFO Implementationgenerate   for(byte_index&#x3D;0; byte_index&lt;&#x3D; (C_S_AXIS_TDATA_WIDTH&#x2F;8-1); byte_index&#x3D;byte_index+1)  begin:FIFO_GEN   &#x2F;&#x2F; reg  [(C_S_AXIS_TDATA_WIDTH&#x2F;4)-1:0] stream_data_fifo [0 : NUMBER_OF_INPUT_WORDS-1];    &#x2F;&#x2F; Streaming input data is stored in FIFO    always @( posedge S_AXIS_ACLK )    begin      if (fifo_wren &amp;&amp; S_AXIS_TSTRB[byte_index])        begin          data_fifo[write_pointer][(byte_index*8+7) -: 8] &lt;&#x3D; S_AXIS_TDATA[(byte_index*8+7) -: 8];         end      end&#x2F;&#x2F; always@(*) begin &#x2F;&#x2F; data_fifo[write_pointer][(byte_index*8+7) -: 8] &#x3D; stream_data_fifo[write_pointer];&#x2F;&#x2F; end   end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>PS:图片来自网络</strong></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AXI4-stream </tag>
            
            <tag> AMBA总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMBA总线（1）——APB总线</title>
      <link href="posts/982f.html"/>
      <url>posts/982f.html</url>
      
        <content type="html"><![CDATA[<p>AMBA协议是一个开放标准的片上互联规范，用于SOC功能模块的连接和管理。目前，已经推出来四代版本的AMBA规范。版本2的AMBA规范定义了3个总线接口：<br>AHB（advanced high-performance bus）：高级高性能总线<br>ASB（advanced sysytem bus ）: 高级系统总线<br>APB（advanced peripheral bus）：高级外设总线</p><p>APB总线用在低带宽和不需要高性能总线的外部设备上，采用流水线结构，所有信号仅与时钟上升沿有关。每次传输至少消耗2个周期。</p><h2 id="APB-信号："><a href="#APB-信号：" class="headerlink" title="APB 信号："></a>APB 信号：</h2><blockquote><p>PCLK：时钟源<br>PRESETN：系统复位信号，低电平有效<br>PADDR：地址总线，最大32位<br>PPROT：保护类型，普通传输，安全传输，数据访问或指令访问<br>PSELx: 片选信号，每个从设备配有一个<br>PENABLE: 使能信号，表示数据传输的第二个及之后的周期。<br>PWRITE: 读写控制信号，高电平为写访问，低电平为读访问<br>PWDATA: 写数据，<br>PSTRB: 字节有效信号，每一个字节对应一位，如果数据位为32，则PSTRB为4位<br>PREADY: 从设备准备好信号，<br>PRDATA: 读取的数据。在读周期里，从设备驱动该总线，最大32位<br>PSLVERR: 传输失败信号</p></blockquote><h2 id="APB-写传输"><a href="#APB-写传输" class="headerlink" title="APB 写传输"></a>APB 写传输</h2><blockquote><p>APB 写传输包括两种类型：无等待状态写传输和有等待状态写传输<br>（1）T1周期<br>给出PADDR，PWRITE，PSELx，PWDATA信号，也称为建立周期<br>（2）T2周期及之后<br>抬高PENBLE信号，等待PREADY信号，如果刚好则是无等待状态传输，否则，PENABLE信号一直保持，直到PREADY信号出现，传输结束，这个是有等待状态传输。<br><img src="/img/apb/c1.png" alt="无等待状态写传输"><br><img src="/img/apb/c2.png" alt="有等待状态写传输"></p></blockquote><h2 id="APB读传输"><a href="#APB读传输" class="headerlink" title="APB读传输"></a>APB读传输</h2><blockquote><p>APB 读传输包括两种类型：无等待状态读传输和有等待状态读传输<br>（1）T1周期<br>给出PADDR，PWRITE，PSELx信号，<br>（2）T2周期及以后<br>抬高PENABLE信号，等待PREADY和PRDATA，如果刚好出现就是无等待读传输，否则PENABLE信号一直保持，直到<br>PREADY和PRDATA出现，这个是有等待状态读传输。<br><img src="/img/apb/c3.png" alt="无等待状态读传输"><br><img src="/img/apb/c4.png" alt="有等待状态读传输"></p></blockquote><h2 id="APB传输状态机"><a href="#APB传输状态机" class="headerlink" title="APB传输状态机"></a>APB传输状态机</h2><blockquote><p><strong>1.IDLE</strong><br>默认状态，无操作<br><strong>2.SETUP</strong><br>建立周期，为一个时钟周期，提供必要的信号.如PSELx信号，PADDR信号等。<br><strong>3.ACCESS</strong><br>数据传输，PENABLE拉高，等待PREADY信号。如果PREADY信号为低，则保持当前状态，否则根据是否要接下来继续在当前地址传输数据来确定下一个状态。具体可看下面的状态机图。</p></blockquote><p><img src="/img/apb/c5.png" alt="APB总线状态机"></p>]]></content>
      
      
      <categories>
          
          <category> 理论知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APB总线 </tag>
            
            <tag> AMBA总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时序约束入门</title>
      <link href="posts/fd6e.html"/>
      <url>posts/fd6e.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-建立时间"><a href="#1-建立时间" class="headerlink" title="1. 建立时间"></a>1. 建立时间</h3><blockquote><p>是指在触发器的时钟信号上升沿到来以前，数据稳定不变的时间，如果建立时间不够，数据将不能在这个时钟上升沿被打入触发器；</p></blockquote><h3 id="2-保持时间"><a href="#2-保持时间" class="headerlink" title="2. 保持时间"></a>2. 保持时间</h3><blockquote><p>是指在触发器的时钟信号上升沿到来以后，数据稳定不变的时间，如果保持时间不够，数据同样不能被打入触发器。</p></blockquote><h3 id="3-时间裕量"><a href="#3-时间裕量" class="headerlink" title="3. 时间裕量"></a>3. 时间裕量</h3><blockquote><p>建立时间裕量：Tsetup_slack<br>就是说在满足建立时间的情况下，所剩余的时间长度为多少，一般大于0；<br>保持时间裕量：Thold_slack<br>就是说在满足保持时间的情况下，所剩余的时间长度为多少，一般大于0；</p></blockquote><h3 id="4-组合逻辑电路延迟-Tlogic"><a href="#4-组合逻辑电路延迟-Tlogic" class="headerlink" title="4. 组合逻辑电路延迟 Tlogic"></a>4. 组合逻辑电路延迟 Tlogic</h3><blockquote><p>两级触发器之间的组合逻辑电路会给信号带来延迟，这个时间就是Tlogic</p></blockquote><h3 id="5-Tco"><a href="#5-Tco" class="headerlink" title="5. Tco"></a>5. Tco</h3><blockquote><p>表示触发器输入端D到输出端Q的延时</p></blockquote><p>下图是触发器时序电路图以及建立时间裕量和保持时间裕量计算公式：<br><img src="/img/STA/b1.png" alt="寄存器时序电路图"><br><img src="/img/STA/b2.png" alt="公式"></p><h2 id="时序分析"><a href="#时序分析" class="headerlink" title="时序分析"></a>时序分析</h2><p>理想情况下的建立时间最大值（就是目的寄存器时钟上升沿的时候，上一数据刚要结束，就被采集到了，也就是数据建立的太早了，数据建立时间出现最大值，保持时间为0），<br>理想情况下的保持时间最大值（目的寄存器时钟上升沿的时候，数据刚开始，被采集到了，也就是数据建立的太晚了，出现建立时间0，数据保持时间出现最大值）。<br>但是实际情况下，寄存器没有这么灵敏，结果就是电路不稳定，出现亚稳态现象。</p><h3 id="1-建立时间裕量"><a href="#1-建立时间裕量" class="headerlink" title="1. 建立时间裕量"></a>1. 建立时间裕量</h3><blockquote><p>如下图。展示的是D1触发器输出端Q的波形和D2触发器输入端D的波形<br><img src="/img/STA/b3.png" alt="波形图"></p></blockquote><blockquote><p>有图可见。D2触发器输入端数据D提前于clk上升沿的时间为 tcycle-(tco+tlogic)，那么他就有这么长的时间来满足建立时间的要求，如果要满足建立时间的话，就要Tcycle-(Tco+Tlogic) &gt; Tsetup,<br>即Tsetup_slack = Tcycle-(Tco+Tlogic) - Tsetup &gt; 0 ,如果加上时钟偏移Tclockdelay,就是Tcycle-(Tco+Tlogic) + Tclockdelay &gt; Tsetup,<br>即Tsetup_slack = Tcycle-(Tco+Tlogic) - Tsetup + Tclockdelay &gt; 0，如下图<br><img src="/img/STA/b5.png" alt="波形图"></p></blockquote><h3 id="2-保持时间裕量"><a href="#2-保持时间裕量" class="headerlink" title="2. 保持时间裕量"></a>2. 保持时间裕量</h3><blockquote><p>如下图，展示的是D1触发器输出端Q的波形和D2触发器输入端D的波形<br><img src="/img/STA/b4.png" alt="波形图"></p></blockquote><blockquote><p>有图可见。D2触发器输入端数据D在clk上升沿到达后的可以持续时间为 Tco+Tlogic。如果要满足建立时间的话，就要Tco+Tlogic &gt; Thold,<br>即Thold_slack = Tco+Tlogic - Thold &gt; 0 ,如果加上时钟偏移Tclockdelay,就是Tco+Tlogic-Tclockdelay &gt; Thold,<br>即Tco+Tlogic-Tclockdelay-Thold &gt; 0，如下图<br><img src="/img/STA/b6.png" alt="波形图"></p></blockquote><p><em><strong>PS:图片来自网络</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IC设计 </tag>
            
            <tag> STA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vcs+verdi安装经历</title>
      <link href="posts/d3e2.html"/>
      <url>posts/d3e2.html</url>
      
        <content type="html"><![CDATA[<p>一直以来我都使用modelsim来进行仿真，也偶尔使用debussy查看波形，最近在别人的推荐下，我开始尝试使用vcs+verdi环境，<br>这篇文章用来记录自己苦逼的安装经历。之前自己下载了vcs verdi sysnopsys等安装包，动手安装但始终会出现一些问题，鉴于<br>时间宝贵，我就直接找了现成安装好的资源。<br>此处感谢微信公众号“芯王国”提供的已经安装好sysnopsys全家桶的vmware虚拟机资源。</p><h2 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h2><blockquote><p>百度云盘链接：<a href="https://pan.baidu.com/s/1enBg_oE8qw9EhU1G9M1qdQ">https://pan.baidu.com/s/1enBg_oE8qw9EhU1G9M1qdQ</a><br>  提取码：8bhi<br>  下载所有文件，然后解压后缀名为.zip的文件，使用vmware打开启动，选择“我已移动”</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>使用terminal终端输入verdi,会出现error:找不到liscense<br>此处我发现公众号提供的虚拟机没有写好环境变量文件，所以我们需要自己去配置。打开etc目录，找到bashrc文件进行修改，或者<br>terminal终端输入</p></blockquote><pre class="line-numbers language-linux" data-language="linux"><code class="language-linux">cd &#x2F;etcsudo gedit bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在bashrc最后添加以下内容：</p><pre class="line-numbers language-none"><code class="language-none">export DVE_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;vcs&#x2F;O-2018.09-SP2export VCS_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;vcs&#x2F;O-2018.09-SP2export VCS_MX_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;vcs-mx&#x2F;O-2018.09-SP2export LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;synopsys&#x2F;verdi&#x2F;Verdi_O-2018.09-SP2&#x2F;share&#x2F;PLI&#x2F;VCS&#x2F;LINUX64export VERDI_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;verdi&#x2F;Verdi_O-2018.09-SP2export SCL_HOME&#x3D;&#x2F;home&#x2F;synopsys&#x2F;scl&#x2F;2018.06#dvePATH&#x3D;$PATH:$VCS_HOME&#x2F;gui&#x2F;dve&#x2F;binalias dve&#x3D;&quot;dve&quot;#VCSPATH&#x3D;$PATH:$VCS_HOME&#x2F;binalias vcs&#x3D;&quot;vcs&quot;#VERDIPATH&#x3D;$PATH:$VERDI_HOME&#x2F;binalias verdi&#x3D;&quot;verdi&quot;#sclPATH&#x3D;$PATH:$SCL_HOME&#x2F;linux64&#x2F;binexport VCS_ARCH_OVERRIDE&#x3D;linux#LICENCEexport LM_LICENSE_FILE&#x3D;27000@localhost.localdomainalias lmg_synopsys&#x3D;&quot;lmgrd -c &#x2F;home&#x2F;synopsys&#x2F;scl&#x2F;2018.06&#x2F;admin&#x2F;license&#x2F;Synopsys.dat&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>点击保存，然后terminal输入：<br><code>source bashrc</code><br><code>lmg_synopsys</code>,<br>我们可以验证license是否正确，可以输入verdi<br>如果没有出现license错误，那就可以使用了<br><strong>note:每次虚拟机打开后都要输入<code>lmg_synopsys</code></strong><br><strong>note:我们最好还要打开/home/synopsys/scl/2018.06/admin/license，查看license.dat文件，查看前两行是否正确：</strong></p><pre class="line-numbers language-none"><code class="language-none">SERVER localhost.localdomain 000c2967fe8c 27000DAEMON snpslmd &#x2F;home&#x2F;synopsys&#x2F;scl&#x2F;2018.06&#x2F;linux64&#x2F;bin&#x2F;snpslmd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次感谢公众号“芯王国”提供的支持。</p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcs </tag>
            
            <tag> verdi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="posts/a9a8.html"/>
      <url>posts/a9a8.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3cfa6f488a9852c70c93260707bfbc98f86a6a367ed4f570c11c738b7f348703">901b05b71b6ef9410c890050abab0ca53675009af90183757c1c8cd406448435a81865033556ecd4bf5218b6d1782603ff5b7dd18cdd5c4aa34f3728d3c3070bd98797c1c450a17b480092fdb3e7e877a1a584c888f19458b0ee6fbd50f4ac2588e94f7a3f08e01979df4d13c44aa933cd1d10704a410af38ab2f92f240d58a5e3ccb78c8444a07ccf96cc35493cf39b5d6fcd012db045c1b83e58e80765c3b2d131c3be48c4533dfad408cf87892374556ca967030335260fae07f1746d190f21699937cc91c2d6cfb5791642dac4188d2da774e6e9d72e77de37f06928b89c235ae84debdd6add8242f9b28ff6c5fae574d96dd3600ef6bb8d3571c4291bf9666ec0adf04ff48e5e05941afec2f93884b63fe38b01b9079b20964b23ea28e609a10cff7a66c3eb57d9730d1c9ec466b4b149893a8f0d5905ef40b0788dd442</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">亲，密码输入就可以看到内容了</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 水笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨时钟域问题解决</title>
      <link href="posts/1635.html"/>
      <url>posts/1635.html</url>
      
        <content type="html"><![CDATA[<p>当信号产生于一个时钟域，并穿过该时钟域边界，作用于另一时钟域时，称该信号为跨时钟信号，由<br>此引发的一系列问题称之为 CDC(clock domain crossing, 简称 CDC)问题。</p><h2 id="跨时钟域风险"><a href="#跨时钟域风险" class="headerlink" title="跨时钟域风险"></a>跨时钟域风险</h2><h3 id="1-亚稳态"><a href="#1-亚稳态" class="headerlink" title="1. 亚稳态"></a>1. 亚稳态</h3><blockquote><p>因为进入的数据未能满足触发器的建立时间和保持时间，触发器的输出在一段时间内无法保持一个确定的状态。如下图1所示，clkA和clkB为不同时钟，第一个触发器输出在DFF2的建立时间和保持时间内不断变化，导致DFF2的输出有误，上下动弹甚至出错，出现了亚稳态现象。图2所示为出现亚稳态时的时序图。<br><img src="https://i.loli.net/2021/03/15/h34k7PvNCpzmdQG.png" alt="图1 跨时钟域电路"><br><img src="https://i.loli.net/2021/03/15/Tq23EIWOPgizdZV.png" alt="图2 亚稳态时序图"></p></blockquote><h3 id="2-数据丢失"><a href="#2-数据丢失" class="headerlink" title="2. 数据丢失"></a>2. 数据丢失</h3><blockquote><p>当数据从快时钟域进入慢时钟域时，会出现慢时钟域没有采样到快时钟域的信号，从而出现数据丢失的情况，进而导致系统出现故障。如下图所示，快时钟域 clockA 输出脉冲信号 Q1 到慢时钟域 clockB，在右侧时序图中可以看到此时 clockB 时钟根本没有采样到该脉冲信号。<br><img src="https://i.loli.net/2021/03/15/AXxLsgfdQHNhuDq.png" alt="图3 数据丢失电路"><br><img src="https://i.loli.net/2021/03/15/JGKYdrixkNeQ4yC.png" alt="图4 电路时序图"></p></blockquote><h2 id="跨时钟域处理"><a href="#跨时钟域处理" class="headerlink" title="跨时钟域处理"></a>跨时钟域处理</h2><h3 id="1-两级同步"><a href="#1-两级同步" class="headerlink" title="1. 两级同步"></a>1. 两级同步</h3><blockquote><p>两级同步就是我们常说的“打两拍”，这可以有效降低亚稳态出现的概率。<strong>两级同步处理只适合单比特电路</strong>。<br>下图所示为两级同步原理图，图中 DB1 是第一个触发器的输出，Dout 是第二个触发器的输出。Dout<br>用来避免亚稳态信号传递到其他后续电路中，一旦同步后的信号有机会稳定下来，就会把信号传递出去。<br>两个触发器之间不加任何逻辑，可以为信号稳定争取足够的时间。<br><img src="https://i.loli.net/2021/03/15/OIjBSzoPv4t8D36.png" alt="图5 两级同步电路"><br><img src="https://i.loli.net/2021/03/15/xszneAW2wJZ4EcK.png" alt="图6 电路时序图"></p></blockquote><h3 id="2-信号展宽"><a href="#2-信号展宽" class="headerlink" title="2. 信号展宽"></a>2. 信号展宽</h3><blockquote><p>信号展宽主要是解决单比特信号<strong>从快时钟域跨越到慢时钟域</strong>时产生信号丢失风险。在快时钟域将跨时<br>钟域信号至少展宽成慢时钟域时钟周期的两倍，使得跨时钟域信号对于目的时钟域来说是一种电平信号。<br>如下图所示，左侧红色椭圆圈内是展宽逻辑，这里仅做示意，只展宽成发送时钟域的两个时钟周期。<br><img src="https://i.loli.net/2021/03/15/Leu7brUD8Pd14Mo.png" alt="图8 信号展宽电路图及时序图"></p></blockquote><h3 id="3-格雷码"><a href="#3-格雷码" class="headerlink" title="3. 格雷码"></a>3. 格雷码</h3><blockquote><p>格雷码的独特之处在于相邻两数变换的时候只有1个bit发生改变，通常用于异步fifo的地址传递。所以对于总线的数据，在跨时钟传递前应该进行格雷码转换，然后再传递出去。<br><img src="https://i.loli.net/2021/03/15/S9pR5iBJU87naXs.png" alt="图9 格雷码转换电路图"></p></blockquote><h3 id="4-握手电路"><a href="#4-握手电路" class="headerlink" title="4. 握手电路"></a>4. 握手电路</h3><blockquote><p><strong>note：仅适用于快时钟域向慢时钟域的数据传输</strong><br>握手电路的步骤是：</p></blockquote><ol><li>源时钟域向目的时钟域发送req信号和数据信号</li><li>目的时钟域接收到req和数据信号后，会回发一个ack信号</li><li>源时钟域接收到ack信号后会拉低req信号，整个数据交换完成<br><img src="https://i.loli.net/2021/03/15/top1x4SuA7z8d6m.png" alt="图10 握手电路原理图"></li></ol><p><strong>note: req信号和ack信号要在对方时钟域进行两级同步</strong><br><img src="https://i.loli.net/2021/03/15/vm1lGxXCg4FwiT2.png" alt="图11 握手电路时序图"></p><h3 id="5-异步fifo"><a href="#5-异步fifo" class="headerlink" title="5. 异步fifo"></a>5. 异步fifo</h3><blockquote><p>一般情况下，基本会采用异步fifo传递数据，不受任何限制。但是异步fifo非常消耗资源。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDC </tag>
            
            <tag> verilog </tag>
            
            <tag> IC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>modelsim使用到的一些tcl脚本</title>
      <link href="posts/5e6f.html"/>
      <url>posts/5e6f.html</url>
      
        <content type="html"><![CDATA[<p>日常modelsim仿真，每次都需要建立工程，添加波形，很是麻烦，于是我就上网搜了一下，总结写了一点脚本来自动编译仿真代码文件。菜鸟学习中，写得不当，还请指正。</p><h2 id="常用指令简介"><a href="#常用指令简介" class="headerlink" title="常用指令简介"></a>常用指令简介</h2><blockquote><p>vlib work :创建名叫work的工作库<br>vmap work work : 映射逻辑库名work到指定的目录<br>vlog test.v :编译名叫test的verilog文件<br>vcom test.vhd :编译名叫test的vhdl文件<br>vsim -voptargs=+acc -L altera_mf test: 仿真test文件，-L表示使用altera库<br><code>add wave /*</code> : 将所有信号waveform dump出来<br>quit -sim : 停止仿真<br>run 10ms :运行10个ms</p></blockquote><h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><blockquote><ol><li>创建一个名叫run的文本文档，将后缀名改为.bat<br>填写内容： </li></ol></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">#C:\modeltech64_10.5\win64\modelsim -do mrun.do#用modelsim仿真则注释下面,根据modelsim安装路径填写上面路径C:\questasim64_10.6c\win64\questasim -do mrun.do#用questasim仿真则注释上面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后关闭</p><blockquote><ol start="2"><li>创建一个名叫mrun的文本文档，将后缀名改为.do<br>填写内容;</li></ol></blockquote><pre class="line-numbers language-none"><code class="language-none">.main clear#清空命令行vlib workvmap work workvlog altera_mf.vvlog filelist.sv#大型工程中，文件众多，可以在filelist中include所有文件#也可以换成vlog src&#x2F;*.v，这需要所以代码放进同一文件夹vsim -novopt -voptargs&#x3D;+acc work.dma_test_top#使用vopt进行设计优化，常与+acc配合使用#vsim用来仿真顶部模块，一般是tb文件，例如上面换成work.test_tbadd log -r &#x2F;*#添加日志，方便仿真中每次添加信号后能自动显示其值，不用重新rundo wave.dorun 10ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后关闭</p><blockquote><ol start="3"><li>创建一个名叫wave的文本文档，将后缀名改为.do<br>填写内容：</li></ol></blockquote><pre class="line-numbers language-none"><code class="language-none">add wave –hex &#x2F;top&#x2F;clk#根据信号引脚填写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为什么要另创建一个wave文件，而不是直接写在mrun.do里，是方便在波形展示界面添加需要查看的信号后可以点击保存信号列表文件，然后覆盖wave文件<br><img src= "/img/modelsim/wave.png" width= "100%"></p><blockquote><ol start="4"><li>filelist文件编写</li></ol></blockquote><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">&#96;include  &quot;.&#x2F;..&#x2F;env&#x2F;ram&#x2F;ram_400_128.v&quot; &#x2F;&#x2F;路径要使用相对路径，本工作目录是和work文件夹在同一目录&#96;include  &quot;.&#x2F;..&#x2F;env&#x2F;ram&#x2F;ram_400_128_add_csn.v&quot;&#x2F;&#x2F; .&#x2F;表示在同一路径   ..&#x2F;表示返回上一目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> modelsim </tag>
            
            <tag> tcl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcl快速入门</title>
      <link href="posts/cb9b.html"/>
      <url>posts/cb9b.html</url>
      
        <content type="html"><![CDATA[<p>TCL是一种很通用的脚本语言，功能强大。最早称为“工具命令语言””Tool Command Language”，但是目前已经不是这个含义，不过我们仍然称呼它TCL，发音为”tickle”。TCL经常被用于快速原型开发，脚本编程，GUI和测试等方面。</p><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><blockquote><p>TCL语言使用<code>$ [] \</code>来实现置换功能<br>$: 解释器会把$后面的认为是变量名，将变量置换成他的值，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set a &quot;zhr&quot;; #赋值给aputs $a;#打印结果为zhrputs a;#打印结果为a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>[ ]</code>:[ ]内是一个独立的TCL语句，例：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set a [expr 3 + 4];puts $a;#打印结果是7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>\</code>: 加上\会变成普通字符,例：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">puts &quot;[expr 3 + 4]&quot;;#结果是7，expr是将运算表达式求值puts &quot;\[[expr 3 + 4]]&quot;;#输出结果是[expr 3 + 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其他字符： { }相当于\ 的功能     #起到注释的作用,此处就不举例说明了</p></blockquote><h2 id="变量数组列表"><a href="#变量数组列表" class="headerlink" title="变量数组列表"></a>变量数组列表</h2><blockquote><p>变量定义 set 变量名 变量值，取值 puts $变量名，例：<br><code>set a &quot;i love you&quot;</code><br><code>puts $a</code></p></blockquote><blockquote><p>数组定义 set 数组名（元素名）值，取值 puts $数组名（元素名），例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set cell(name) &quot;zhr&quot;;puts $cell(name)；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以使用array获取数组信息，例：<br><code>array size cell</code>或者<code>array name cell</code></p><blockquote><p>列表定义 set 列表名 {元素1 元素2}，取值 puts $列表名，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set list &#123;list1 list2 list3&#125;;puts $list;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本人觉得列表和变量的使用方法相同</p><h2 id="列表指令"><a href="#列表指令" class="headerlink" title="列表指令"></a>列表指令</h2><blockquote><p>contact: 合并两列表，例： </p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">contact $list1 $list2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>llength: 返回元素个数，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">llength $list1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>lindex: 返回列表第n个元素，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">lindex $list1 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>lappend: 末尾加入新元素，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">lappend list1 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>lsort: 排序，后面可加参数 -real 按浮点数大小排  -unique 删除重复，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">lsort (real) $list1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><blockquote><p>if语句：和c语言中的if语句功能十分相似，例</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">if &#123; 表达式 &#125; &#123;            #运算;        &#125; else &#123;             #其他运算;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>foreach语句：把列表里第0个元素开始，依次把值赋给变量，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">foreach i $list&#123;  # 把list里的元素依次给iputs $i&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>break语句</p></blockquote><img src="/img/tcl/break.jpg" width = "100%"><blockquote><p>continue语句<br><img src="/img/tcl/continue.png" width = "100%"></p></blockquote><blockquote><p>while语句<br><img src="/img/tcl/while.png" width = "100%"></p></blockquote><blockquote><p>for语句结构：for{initialization} {condition} {increment} {body}，例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">for &#123;set i 0&#125; &#123;$i&lt; 10&#125; &#123;incr i&#125; &#123;puts $i;&#125;  #将打印出0到9&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="过程函数"><a href="#过程函数" class="headerlink" title="过程函数"></a>过程函数</h2><img src="/img/tcl/proc.png" width = "100%"><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><blockquote><p>正则表达式是按照字符匹配规则提取出自己需要的字符内容，字符匹配规则如下：<br>正则表达式的\w，是匹配一个字母、数字或下划线，<br>正则表达式的\d,是匹配数字，<br>正则表达式的\s，用来匹配空格，<br>正则表达式的<code>.</code>,用来匹配任一字符，<br>正则表达式的<code>*</code>用来进行零次或多次匹配，<code>+</code>用来一次或多次匹配，<code>?</code>用来零次或一次匹配，<br>正则表达式的<code>^</code>用来表示字符串开头，<code>$</code>表示字符串结尾。</p></blockquote><p>我们使用正则匹配指令regexp来进行正则匹配。例：</p><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">regexp &#123;\s(\d+).*&#125; &quot;snow is 30 years old&quot; total age puts $total#输出30 years oldputs $age#输出30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><blockquote><p>文本处理在日常生活中十分常用，tcl脚本中用于文本处理的一般是open,gets,close;例：</p></blockquote><pre class="line-numbers language-tcl" data-language="tcl"><code class="language-tcl">set f01 [open &quot;fix.tcl&quot; w];# 命令表示 打开或者新建一个文件“fix.tcl”，并将其 file ID 设置为 f01，后续就以这个 file ID 来操作这个文件；puts  $f01 &quot;size_cell $cel_name $ref_name&quot; ;#这条命令表示将这个字符串写入文件 fix.tcl，并自动追加换行符；close $f01 ;#对文件操作完成后，需要将其关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tcl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="posts/b859.html"/>
      <url>posts/b859.html</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。笔者写这篇文章主要是写给自己看，熟能生巧，也顺便推广一波markdown。</p><span id="more"></span><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h2><blockquote><p>一个#表示一级标题，两个表示二级标题，最多可使用6个#，代码如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 一级标题## 二级标题### 三级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>可以使用<code>**加粗**</code>显示<br>使用<code>*斜体*</code>显示<br>使用<code>***加粗斜体***</code>显示<br>使用删除线<code>~~删除线~~</code>显示<br>展示效果如下：</p></blockquote><blockquote><p><strong>加粗</strong><br><em>斜体</em><br><em><strong>加粗斜体</strong></em><br><del>删除线</del></p></blockquote><h2 id="2-图片"><a href="#2-图片" class="headerlink" title="2.图片"></a>2.图片</h2><blockquote><p>代码格式：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">![alt 属性文本](图片地址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举例来说：</p><pre class="line-numbers language-none"><code class="language-none">![龙猫](https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;15&#x2F;LCEZXoG953nzxpc.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果图片地址为本地，就是</p><pre class="line-numbers language-none"><code class="language-none">![龙猫](&#x2F;img&#x2F;markdown&#x2F;cat.png)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>效果展示：<br><img src="https://i.loli.net/2021/03/15/LCEZXoG953nzxpc.jpg" alt="龙猫"></p><blockquote><p>markdown不能改变图片大小，可以使用普通的 <code>&lt;img&gt;</code> 标签<code>&lt;img src=&quot;/img/markdown/cat.png&quot; width=&quot;50%&quot;&gt;</code><br>效果展示：</p></blockquote><img src="/img/markdown/cat.png" width="50%"><h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h2><blockquote><p>一般可以选择在代码前使用 4 个空格或者一个制表符（Tab 键）。<br>又或者在代码上下一行使用```,<br>本人觉得第二种方便使用，前一种不知是不是我方法问题，无法奏效<br>例：</p></blockquote><pre class="line-numbers language-md" data-language="md"><code class="language-md">&#96;&#96;&#96;printf(&quot;i love you&quot;);&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>还有一种，段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#96;printf(&quot;i love you&quot;);&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h2><blockquote><p>代码格式：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">[链接名称](链接地址)或者&lt;链接地址&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：<code>这是我的[博客地址](https://yjgcszhr.github.io/)</code></p><blockquote><p> 效果就是：<br>    这是我的<a href="https://yjgcszhr.github.io/">博客地址</a></p></blockquote><h2 id="5-区块和列表"><a href="#5-区块和列表" class="headerlink" title="5.区块和列表"></a>5.区块和列表</h2><blockquote><p>区块是在段落开头使用<code>&gt;</code>，并空一格<br> 列表使用<code>星号(*)、加号(+)或是减号(-)</code>作为列表标记，或者<code>数字并加上 . 号</code>表示 </p></blockquote><pre class="line-numbers language-none"><code class="language-none"> &gt; 区块中使用列表&gt; 1. 第一项&gt;&gt; 2. 第二项&gt; + 第一项&gt; - 第二项&gt; * 第三项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果展示：</p><blockquote><p>区块中使用列表</p><ol><li>第一项<blockquote><ol start="2"><li>第二项</li></ol></blockquote></li></ol><ul><li>第一项</li></ul><ul><li>第二项</li></ul><ul><li>第三项</li></ul></blockquote><h2 id="6-表格"><a href="#6-表格" class="headerlink" title="6.表格"></a>6.表格</h2><p>使用<code>|</code>来分隔不同的单元格，使用 <code>---- </code>来分隔表头和其他行。</p><p>语法格式如下：</p><pre class="line-numbers language-md" data-language="md"><code class="language-md">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>效果展示：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/3eeb.html"/>
      <url>posts/3eeb.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
